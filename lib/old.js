// Generated by CoffeeScript 1.7.1
(function() {
  var Fussy, Lazy, Url, colors, csv, debug, extract, fs, mime, path, pretty, unzip, util, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  util = require('util');

  Url = require('url');

  Lazy = require('lazy.js');

  unzip = require('unzip');

  mime = require('mime');

  colors = require('colors');

  csv = require('ya-csv');

  utils = require('./utils');

  extract = require('./extract');

  pretty = utils.pretty;

  debug = function(x) {
    return console.log(x);
  };

  Fussy = (function() {
    function Fussy(input) {
      this.input = input;
      this.pretty = utils.pretty;
      this.pperf = utils.pperf;
      this.pstats = utils.pstats;
    }

    Fussy.prototype._parse = function(data) {
      var exc, output;
      debug("    .parse(data)" + "  // convert raw chunk into full featured object".grey);
      output = void 0;
      if (flow.schema != null) {
        if (utils.isString(data)) {
          try {
            output = utils.parse(flow.schema, data);
          } catch (_error) {
            exc = _error;
            debug("couldn't parse line, trying to parse json from string");
            try {
              output = JSON.parse(data);
            } catch (_error) {
              exc = _error;
              debug("couldn't parse json. I could use the object as is, but since you defined a schema I prefer to skip it");
              output = void 0;
            }
          }
        } else {
          output = data;
        }
      } else if (utils.isString(data)) {
        debug("no schema, trying to parse json from string");
        output = JSON.parse(data);
      } else {
        debug("no schema, using js object as-is");
        output = data;
      }
      debug("" + (pretty(input)) + " =====> " + (pretty(output)));
      return output;
    };

    Fussy.prototype._extract = function(event, facts, prefix) {
      var exc, key, value;
      if (facts == null) {
        facts = [];
      }
      if (prefix == null) {
        prefix = "";
      }

      /*
      This was supposed to be a built-in support for a "date" attribute
      TODO but it is a bit awkward: we should rather use the schema for that.
      let's disable it for now.
       */
      try {
        for (key in event) {
          value = event[key];
          key = prefix + key;
          if (utils.isString(value)) {
            facts.push(['String', key, value]);
          } else if (utils.isArray(value)) {
            facts.push(['Array', key, value]);
          } else if (utils.isNumber(value)) {
            facts.push(['Number', key, value]);
          } else if (utils.isBoolean(value)) {
            facts.push(['Boolean', key, value]);
          } else {
            this._extract(value, facts, key + ".");
          }
        }
      } catch (_error) {
        exc = _error;
        console.log("failed: " + exc);
        console.log(exc);
      }
      return facts;
    };

    Fussy.prototype.schema = function(schema) {
      this._schema = schema;
      return this;
    };

    Fussy.prototype.query = function(query) {
      debug("query");
      return {
        onError: function(cb) {
          var err;
          err = "unknow error";
          return cb(err);
        },
        onComplete: function(cb) {
          var result;
          debug("onComplete");
          result = {};
          return cb(result);
        }
      };
    };

    Fussy.prototype._pipeline = function(input) {
      var extracted, parsed;
      parsed = this._parse(input);
      extracted = this._extract(parsed);
      return extracted;
    };

    return Fussy;

  })();

  module.exports = {
    database: function(input) {
      return new Fussy(input);
    }
  };

  Fussy.lazy = function(input) {
    var flow;
    debug("\n  // calling Fussy.lazy(..) behind the hood".grey);
    if (input.async == null) {
      throw "error, input cannot be made asynchronous";
    }
    flow = {
      schema: void 0,
      input: input
    };
    flow.parse = function(schema) {
      var exc;
      debug(("  .parse(\"" + schema + "\")") + " // loading schema".grey);
      try {
        flow.schema = utils.loadSchema(schema);
      } catch (_error) {
        exc = _error;
        debug("couldn't read schema: " + exc);
        flow.schema = void 0;
      }
      return flow;
    };
    flow.drop = function(n) {
      flow.input = flow.input.drop(n);
      return flow;
    };
    flow.take = function(n) {
      flow.input = flow.input.take(n);
      return flow;
    };
    flow.rest = function(n) {
      flow.input = flow.input.rest(n);
      return flow;
    };
    flow.shuffle = function() {
      flow.input = flow.input.shuffle();
      return flow;
    };
    flow.where = function(properties) {
      flow.input = flow.input.where(properties);
      return flow;
    };
    flow.sortBy = function(sortFn) {
      return flow.input = flow.input.sortBy(sortFn);
    };
    flow.query = function(query) {
      var all, best, mix, reduceFn, select, tmp, _i, _len, _ref;
      debug("  .query()" + "      // preparing the rabbit".grey);
      if (query.select != null) {
        if (utils.isString(query.select)) {
          tmp = {};
          tmp[query.select] = [];
          query.select = tmp;
        } else if (utils.isArray(query.select)) {
          tmp = {};
          _ref = query.select;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            select = _ref[_i];
            tmp[select] = [];
          }
          query.select = tmp;
        }
      }
      if (!utils.isArray(query.where)) {
        query.where = [query.where];
      }
      reduceFn = function(aggregated, features) {
        var complexity, delta, depth, factors, key, match, nb_feats, type, value, weight, where, whereValue, whereValues, _depth, _j, _k, _l, _len1, _len2, _len3, _len4, _m, _nb_feats, _ref1, _ref2, _ref3, _ref4;
        debug("    .reduceFn()" + " // deep comparison".grey);
        weight = 0;
        factors = [];
        nb_feats = 0;
        _ref1 = query.where;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          where = _ref1[_j];
          depth = 0;
          complexity = 0;
          for (_k = 0, _len2 = features.length; _k < _len2; _k++) {
            _ref2 = features[_k], type = _ref2[0], key = _ref2[1], value = _ref2[2];
            if (key in where) {
              whereValues = utils.isArray(where[key]) ? where[key] : [where[key]];
              match = false;
              for (_l = 0, _len3 = whereValues.length; _l < _len3; _l++) {
                whereValue = whereValues[_l];
                switch (type) {
                  case 'String':
                    value = "" + value;
                    whereValue = "" + whereValue;
                    if (__indexOf.call(value, ' ') >= 0 || __indexOf.call(whereValue, ' ') >= 0) {
                      _ref3 = text.distance(value, whereValue), _depth = _ref3[0], _nb_feats = _ref3[1];
                      depth += _depth;
                      nb_feats += _nb_feats;
                      match = true;
                    } else {
                      if (value === whereValue) {
                        depth += 1;
                        match = true;
                      }
                    }
                    break;
                  case 'Number':
                    whereValue = Number(whereValue);
                    if (!isNaN(whereValue) && isFinite(whereValue)) {
                      delta = Math.abs(value - whereValue);
                      depth += 1 / (1 + delta);
                      match = true;
                    }
                    break;
                  case 'Boolean':
                    if ((Boolean(value)) === (Boolean(whereValue))) {
                      depth += 1;
                      match = true;
                    }
                    break;
                  default:
                    debug("type " + type + " not supported");
                }
              }
              if (match) {
                nb_feats += 1;
              }
            }
          }
          depth *= Math.min(6, 300 / nb_feats);
          weight += Math.pow(10, Math.min(300, depth));
        }
        for (_m = 0, _len4 = features.length; _m < _len4; _m++) {
          _ref4 = features[_m], type = _ref4[0], key = _ref4[1], value = _ref4[2];
          if (query.select != null) {
            if (!(key in query.select)) {
              continue;
            }
          }
          if (!(key in aggregated.types)) {
            aggregated.types[key] = type;
          }
          if (!(key in aggregated.result)) {
            aggregated.result[key] = {};
          }
          if (!(value in aggregated.result[key])) {
            aggregated.result[key][value] = 0;
          }
          match = false;
          if (utils.isArray(query.select[key])) {
            if (query.select[key].length) {
              if (__indexOf.call(query.select[key], value) >= 0) {
                match = true;
              }
            } else {
              match = true;
            }
          } else {
            if (value === query.select[key]) {
              match = true;
            }
          }
          if (match) {
            aggregated.result[key][value] += weight;
          }
        }
        debug("generated aggregated result");
        return aggregated;
      };
      all = function() {
        debug("  .all()" + "        // calling blocking reduce() function".grey);
        ({
          onComplete: function(cb) {
            debug(".onComplete()");
            flow.input.toArray().onError(function(error) {
              console.log("    .onError()");
              console.log(error);
              return console.trace();
            }).onComplete(function(arr) {
              var castFn, res, result, sortFn, types, _ref1;
              debug("    .onComplete()");
              debug("initializing");
              _ref1 = Lazy(arr).map(parseFn).compact().reduce(reduceFn, {
                result: {},
                types: {}
              }), result = _ref1.result, types = _ref1.types;
              debug("result: " + pretty(result));
              sortFn = function(input) {
                var output;
                debug("    .sortFn()" + " // sort options by probability".grey);
                output = input.sort(function(a, b) {
                  return b[2] - a[2];
                });
                return output;
              };
              castFn = function(input) {
                var key, option, options, weight, _results, _results1, _results2;
                debug("    .castFn()" + "  // cast output map to typed array");
                key = input[0], options = input[1];
                if (types[key] === 'Number') {
                  _results = [];
                  for (option in options) {
                    weight = options[option];
                    _results.push([key, Number(option, weight)]);
                  }
                  return _results;
                } else if (types[key] === 'Boolean') {
                  _results1 = [];
                  for (option in options) {
                    weight = options[option];
                    _results1.push([key, Boolean(option, weight)]);
                  }
                  return _results1;
                } else {
                  _results2 = [];
                  for (option in options) {
                    weight = options[option];
                    _results2.push([key, option, weight]);
                  }
                  return _results2;
                }
              };
              console.log("third lazy: for results");
              return res = Lazy(result).pairs().map(castFn).map(sortFn).toArray();
            });
            return cb(res);
          }
        });
        return void 0;
      };
      best = function() {
        var result, types, _ref1;
        debug("best");
        _ref1 = flow.output.reduce(reduceFn, {
          result: {},
          types: {}
        }), result = _ref1.result, types = _ref1.types;
        Lazy(reduced.result).pairs().map(function(input) {
          var key, option, options, output, weight;
          key = input[0], options = input[1];
          output = [];
          for (option in options) {
            weight = options[option];
            if (reduced.types[key] === 'Number') {
              option = Number(option);
            } else if (reduced.types[key] === 'Boolean') {
              option = Boolean(option);
            }
            output.push([option, weight]);
          }
          output.sort(function(a, b) {
            return b[1] - a[1];
          });
          return output = output[0][0];
        });
        return Lazy(result);
      };
      mix = function() {
        var isNumerical, key, option, options, result, sum, types, weight, _ref1, _ref2;
        debug("mix");
        _ref1 = flow.output.reduce(reduceFn, {
          result: {},
          types: {}
        }), result = _ref1.result, types = _ref1.types;
        result = {};
        _ref2 = reduced.result;
        for (key in _ref2) {
          options = _ref2[key];
          isNumerical = reduced.types[key] === 'Number';
          if (utils.isNumerical) {
            sum = 0;
            for (option in options) {
              weight = options[option];
              sum += weight;
            }
            result[key] = 0;
            for (option in options) {
              weight = options[option];
              option = Number(option);
              result[key] += option * (weight / sum);
            }
          } else {
            result[key] = [];
            for (option in options) {
              weight = options[option];
              if (reduced.types[key] === 'Boolean') {
                option = Boolean(option);
              }
              result[key].push([option, weight]);
            }
            result[key].sort(function(a, b) {
              return b[1] - a[1];
            });
            best = result[key][0];
            result[key] = best[0];
          }
        }
        return Lazy(result);
      };
      return {
        all: all,
        best: best,
        mix: mix
      };
    };
    return flow;
  };

  Fussy.mongo = function(input) {
    if ((input == null) || input === '') {
      throw new Error('Empty or null input');
    }
    throw new Error("Not Implemented");
  };

  Fussy.sequence = function(input) {
    var lazy;
    if ((input == null) || input === '') {
      throw new Error('Empty or null input');
    }
    lazy = Lazy(input);
    return Fussy.lazy(lazy);
  };

  Fussy.file = function(input) {
    var lazy, lazySequence, mimetype;
    if ((input == null) || input === '') {
      throw new Error('Empty or null input');
    }
    debug("Fussy.file(\"" + input + "\")");
    mimetype = mime.lookup(input);
    switch (mimetype) {
      case 'text/csv':
        lazy = Lazy.readFile(input).lines();
        return Fussy.lazy(lazy);
      case 'application/zip':
        lazySequence = new StreamedSequence(void 0);
        fs.createReadStream(input, {
          autoClose: true
        }).pipe(unzip.Parse()).on('entry', function(entry) {
          var type;
          if (entry.type === 'Directory') {
            debug("ignoring directory");
            entry.autodrain();
            return;
          }
          type = mime.lookup(entry.path);
          switch (type) {
            case 'text/csv':
              debug("found a csv file in the archive, reading: " + entry.path + " (size: " + entry.size + ")");
              if (lazySequence.stream != null) {
                debug("error, lazy sequence already initialized");
                entry.autodrain();
              } else {
                debug("initializing lazy sequence");
                return lazySequence.stream = entry;
              }
              break;
            default:
              debug("found some \"" + type + "\" in the archive, ignoring: " + entry.path);
              return entry.autodrain();
          }
        });
        return lazySequence;
      default:
        throw " unsupported file type \"" + type + "\" ";
    }
  };

  Fussy.http = function(url) {
    if ((typeof input === "undefined" || input === null) || input === '') {
      throw new Error('Empty or null input');
    }
    return Fussy.lazy(Lazy.makeHttpRequest(url).lines());
  };

  Fussy.open = function(url) {
    var protocol, _ref;
    if (!isString(input)) {
      return Fussy.lazy(Lazy(input));
    }
    _ref = Url.parse(url), protocol = _ref.protocol, path = _ref.path;
    switch (protocol) {
      case 'http:':
      case 'http+csv:':
      case 'http+json':
      case 'https:':
      case 'https+csv:':
      case 'https+json':
        debug("http: making an http request");
        return Fussy.http(url);
      case 'file:':
      case 'file+csv:':
      case 'file+json:':
      case 'file+txt:':
        debug("file: reading a file stream from url's path");
        return Fussy.file(path);
      default:
        debug("default: reading a file stream from normal path");
        return Fussy.file(url);
    }
  };

}).call(this);
