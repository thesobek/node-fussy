// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var Query, colors, deck, pretty, text, util, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  util = require('util');

  colors = require('colors');

  deck = require('deck');

  utils = require('./utils');

  text = require('./text');

  pretty = utils.pretty;

  Query = (function() {
    function Query(_fussy, q) {
      var select, tmp, _i, _len, _ref;
      this._fussy = _fussy;
      this._error = void 0;
      this._mode = 'all';
      if (q.select != null) {
        if (utils.isString(q.select)) {
          tmp = {};
          tmp[q.select] = [];
          q.select = tmp;
        } else if (utils.isArray(q.select)) {
          tmp = {};
          _ref = q.select;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            select = _ref[_i];
            tmp[select] = [];
          }
          q.select = tmp;
        }
      }
      if (!utils.isArray(q.where)) {
        q.where = [q.where];
      }
      this._query = q;
    }

    Query.prototype.debug = function(enabled) {
      this._debugEnabled = enabled;
      return this;
    };

    Query.prototype._debug = function(x) {
      if (!(this._debugEnabled != null ? this._debugEnabled : this._fussy._debugEnabled)) {
        return;
      }
      return console.log("Query".green + "::".grey + x);
    };

    Query.prototype._reduceFn = function(reduction, features) {
      var complexity, delta, depth, factors, key, match, nb_feats, query, type, value, weight, where, whereValue, whereValues, _depth, _i, _j, _k, _l, _len, _len1, _len2, _len3, _nb_feats, _ref, _ref1, _ref2, _ref3;
      this._debug("reduceFn(reduction, features)" + " // deep comparison".grey);
      if (features == null) {
        this._debug("reduceFn: end condition");
        return reduction;
      }
      query = reduction.query;
      weight = 0;
      factors = [];
      nb_feats = 0;
      _ref = query.where;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        where = _ref[_i];
        depth = 0;
        complexity = 0;
        for (_j = 0, _len1 = features.length; _j < _len1; _j++) {
          _ref1 = features[_j], type = _ref1[0], key = _ref1[1], value = _ref1[2];
          if (key in where) {
            whereValues = utils.isArray(where[key]) ? where[key] : [where[key]];
            match = false;
            for (_k = 0, _len2 = whereValues.length; _k < _len2; _k++) {
              whereValue = whereValues[_k];
              switch (type) {
                case 'String':
                  value = "" + value;
                  whereValue = "" + whereValue;
                  if (__indexOf.call(value, ' ') >= 0 || __indexOf.call(whereValue, ' ') >= 0) {
                    _ref2 = text.distance(value, whereValue), _depth = _ref2[0], _nb_feats = _ref2[1];
                    depth += _depth;
                    nb_feats += _nb_feats;
                    match = true;
                  } else {
                    if (value === whereValue) {
                      depth += 1;
                      match = true;
                    }
                  }
                  break;
                case 'Number':
                  whereValue = Number(whereValue);
                  if (!isNaN(whereValue) && isFinite(whereValue)) {
                    delta = Math.abs(value - whereValue);
                    depth += 1 / (1 + delta);
                    match = true;
                  }
                  break;
                case 'Boolean':
                  if ((Boolean(value)) === (Boolean(whereValue))) {
                    depth += 1;
                    match = true;
                  }
                  break;
                default:
                  this._debug("type " + type + " not supported");
              }
            }
            if (match) {
              nb_feats += 1;
            }
          }
        }
        depth *= Math.min(6, 300 / nb_feats);
        weight += Math.pow(10, Math.min(300, depth));
      }
      for (_l = 0, _len3 = features.length; _l < _len3; _l++) {
        _ref3 = features[_l], type = _ref3[0], key = _ref3[1], value = _ref3[2];
        if (query.select != null) {
          if (!(key in query.select)) {
            continue;
          }
        }
        if (!(key in reduction.types)) {
          reduction.types[key] = type;
        }
        if (!(key in reduction.result)) {
          reduction.result[key] = {};
        }
        if (!(value in reduction.result[key])) {
          reduction.result[key][value] = 0;
        }
        match = false;
        if (query.select != null) {
          if (utils.isArray(query.select[key])) {
            if (query.select[key].length) {
              if (__indexOf.call(query.select[key], value) >= 0) {
                match = true;
              }
            } else {
              match = true;
            }
          } else {
            if (value === query.select[key]) {
              match = true;
            }
          }
        } else {
          match = true;
        }
        if (match) {
          reduction.result[key][value] += weight;
        }
      }
      this._debug("_reduceFn: reducing");
      return reduction;
    };

    Query.prototype._toBestFn = function(args, cb) {
      var best, isNumerical, key, option, options, output, result, sum, types, weight, ws;
      this._debug("_toBestFn(args)");
      result = args.result, types = args.types;
      output = {};
      for (key in result) {
        options = result[key];
        this._debug("_toBestFn: " + key + ": " + (pretty(options)));
        isNumerical = types[key] === 'Number';
        if (isNumerical) {
          sum = 0;
          for (option in options) {
            weight = options[option];
            sum += weight;
          }
          output[key] = 0;
          for (option in options) {
            weight = options[option];
            option = Number(option);
            if (sum > 0) {
              ws = weight / sum;
              output[key] += option * ws;
            } else {
              output[key] += option * weight;
            }
          }
        } else {
          output[key] = [];
          for (option in options) {
            weight = options[option];
            if (types[key] === 'Boolean') {
              option = Boolean(option);
            }
            output[key].push([option, weight]);
          }
          output[key].sort(function(a, b) {
            return b[1] - a[1];
          });
          best = output[key][0];
          output[key] = best[0];
        }
      }
      if (cb != null) {
        cb(output);
        return void 0;
      } else {
        return output;
      }
    };

    Query.prototype._toAllFn = function(args, cb) {
      var result, __toAllFn;
      this._debug("_toAllFn(args, cb?)" + "  // cast output map to typed array");
      __toAllFn = (function(_this) {
        return function(_args) {
          var key, option, options, sorted, weight, _ref;
          _this._debug("_toAllFn:__toAllFn()");
          _ref = _args.result;
          for (key in _ref) {
            options = _ref[key];
            sorted = [];
            if (_args.types[key] === 'Number') {
              _this._debug("_toAllFn:__toAllFn: Number -> " + key);
              for (option in options) {
                weight = options[option];
                sorted.push([Number(option), weight]);
              }
            } else if (_args.types[key] === 'Boolean') {
              _this._debug("_toAllFn:__toAllFn: Boolean -> " + key);
              for (option in options) {
                weight = options[option];
                sorted.push([Boolean(option), weight]);
              }
            } else {
              _this._debug("_toAllFn:__toAllFn: String -> " + key);
              for (option in options) {
                weight = options[option];
                sorted.push([option, weight]);
              }
            }
            _args.result[key] = sorted.sort(function(a, b) {
              return b[1] - a[1];
            });
          }
          return _args.result;
        };
      })(this);
      if (cb != null) {
        result = __toAllFn(args);
        cb(result);
        return void 0;
      } else {
        result = __toAllFn(args);
        return result;
      }
    };

    Query.prototype.trigger = function(cb) {
      if (cb != null) {
        return this._async(cb);
      } else {
        return this._sync();
      }
    };

    Query.prototype.all = function(cb) {
      this._debug("all(cb?)");
      this._mode = 'all';
      return this.trigger(cb);
    };

    Query.prototype.best = function(cb) {
      this._debug("mix(cb?)");
      this._mode = 'best';
      return this.trigger(cb);
    };

    Query.prototype.replace = function(cb) {
      this._debug("replace(cb?)");
      this._mode = 'replace';
      return this.trigger(cb);
    };

    Query.prototype.pick = function(n, cb) {
      this._debug("pick(" + n + ", cb?)");
      this._mode = 'pick';
      this._pick_instances = n;
      return this.trigger(cb);
    };

    Query.prototype.generate = function(cb) {
      this._debug("generate(cb?)");
      this._mode = 'generate';
      return this.trigger(cb);
    };

    Query.prototype._sync = function() {
      var ctx, i, k, key, obj, option, options, res, result, results, v;
      this._debug("_sync()");
      ctx = {
        query: this._query,
        result: {},
        types: {}
      };
      this._debug("_sync: @_fussy.eachFeatureSync:");
      this._fussy.eachFeaturesSync((function(_this) {
        return function(features, isLastItem) {
          _this._debug("_sync: @_fussy.eachFeatureSync(" + (pretty(features)) + ", " + (pretty(isLastItem)) + ")");
          return ctx = _this._reduceFn(ctx, features);
        };
      })(this));
      results = (function() {
        switch (this._mode) {
          case 'all':
            this._debug("_sync: all: @_toAllFn()");
            return this._toAllFn(ctx);
          case 'pick':
            this._debug("_sync: pick");
            res = (function() {
              var _i, _ref, _ref1, _results;
              _results = [];
              for (i = _i = 0, _ref = this._pick_instances; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                obj = {};
                _ref1 = ctx.result;
                for (key in _ref1) {
                  options = _ref1[key];
                  option = deck.pick(options);
                  obj[key] = option;
                }
                _results.push(obj);
              }
              return _results;
            }).call(this);
            if (utils.isArray(res)) {
              if (res.length === 1) {
                res = res[0];
              }
            }
            return res;
          case 'generate':
            this._debug("_sync: generate");
            return (function(_this) {
              return function() {
                var _ref;
                obj = {};
                _ref = ctx.result;
                for (key in _ref) {
                  options = _ref[key];
                  option = deck.pick(options);
                  obj[key] = option;
                }
                return obj;
              };
            })(this);
          case 'best':
            this._debug("_sync: best: @_toBestFn(" + (pretty(ctx)) + ")");
            return this._toBestFn(ctx);
          case 'replace':
            this._debug("_sync: fix: @_toBestFn(" + (pretty(ctx)) + ")");
            result = this._toBestFn(ctx);
            obj = ctx.query.replace;
            for (k in result) {
              v = result[k];
              if (obj[k] == null) {
                obj[k] = v;
              }
            }
            return obj;
        }
      }).call(this);
      this._debug("_sync: return " + (pretty(results)));
      return results;
    };

    Query.prototype.onError = function(cb) {
      this._debug("onError(cb)");
      return this._onError = cb;
    };

    Query.prototype._async = function(cb) {
      var ctx;
      this._debug("_async(cb)");
      ctx = {
        query: this._query,
        result: {},
        types: {}
      };
      this._debug("_async: @_fussy.eachFeatureAsync:");
      this._fussy.eachFeaturesAsync((function(_this) {
        return function(features, isLastItem) {
          var i, key, obj, option, options, res;
          _this._debug("_async: @_fussy.eachFeatureAsync(" + (pretty(features)) + ", " + (pretty(isLastItem)) + ")");
          _this._debug("_async: @_reduceFn(ctx, features)");
          ctx = _this._reduceFn(ctx, features);
          if (!isLastItem) {
            return;
          }
          _this._debug("_async: isLastItem == true");
          switch (_this._mode) {
            case 'all':
              _this._debug("_async: all: @_toAllFn(ctx, cb)");
              return _this._toAllFn(ctx, function(results) {
                _this._debug("_async: all: cb(results)");
                return cb(results);
              });
            case 'pick':
              _this._debug("_sync: pick");
              res = (function() {
                var _i, _ref, _ref1, _results;
                _results = [];
                for (i = _i = 0, _ref = this._pick_instances; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                  obj = {};
                  _ref1 = ctx.result;
                  for (key in _ref1) {
                    options = _ref1[key];
                    option = deck.pick(options);
                    obj[key] = option;
                  }
                  _results.push(obj);
                }
                return _results;
              }).call(_this);
              if (utils.isArray(res)) {
                if (res.length === 1) {
                  res = res[0];
                }
              }
              return cb(res);
            case 'generate':
              _this._debug("_async: generate");
              return cb(function() {
                var _ref;
                obj = {};
                _ref = ctx.result;
                for (key in _ref) {
                  options = _ref[key];
                  option = deck.pick(options);
                  obj[key] = option;
                }
                return obj;
              });
            case 'best':
              _this._debug("_async: best: @_toBestFn(" + (pretty(ctx)) + ")");
              return _this._toBestFn(ctx, function(results) {
                _this._debug("_async: best: cb(results)");
                return cb(results);
              });
            case 'replace':
              _this._debug("_async: replace: @_toBestFn(" + (pretty(ctx)) + ")");
              return _this._toBestFn(ctx, function(results) {
                var k, v;
                _this._debug("_async: replace: @_toBestFn: results: " + (pretty(results)));
                obj = ctx.query.replace;
                for (k in results) {
                  v = results[k];
                  if (obj[k] == null) {
                    obj[k] = v;
                  }
                }
                obj;
                return cb(obj);
              });
          }
        };
      })(this));
      return void 0;
    };

    return Query;

  })();

  module.exports = Query;

}).call(this);
