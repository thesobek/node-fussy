// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var Query, colors, deck, pretty, text, util, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  util = require('util');

  colors = require('colors');

  deck = require('deck');

  utils = require('./utils');

  text = require('./text');

  pretty = utils.pretty;

  Query = (function() {
    function Query(_fussy, queries, isSingle) {
      var q, select, tmp;
      this._fussy = _fussy;
      this._error = void 0;
      this._mode = 'all';
      this._isSingle = isSingle;
      this._maxOptions = 5;
      this._queries = (function() {
        var _i, _j, _len, _len1, _ref, _results;
        _results = [];
        for (_i = 0, _len = queries.length; _i < _len; _i++) {
          q = queries[_i];
          if (q.select != null) {
            if (utils.isString(q.select)) {
              tmp = {};
              tmp[q.select] = [];
              q.select = tmp;
            } else if (utils.isArray(q.select)) {
              tmp = {};
              _ref = q.select;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                select = _ref[_j];
                tmp[select] = [];
              }
              q.select = tmp;
            }
          }
          if (!utils.isArray(q.where)) {
            q.where = [q.where];
          }
          _results.push(q);
        }
        return _results;
      })();
    }

    Query.prototype.debug = function(enabled) {
      this._debugEnabled = enabled;
      return this;
    };

    Query.prototype._debug = function(x) {
      if (!(this._debugEnabled != null ? this._debugEnabled : this._fussy._debugEnabled)) {
        return;
      }
      return console.log("Query".green + "::".grey + x);
    };

    Query.prototype._reduceFn = function(requests, features) {
      var complexity, delta, depth, factors, key, match, nb_feats, request, type, value, weight, where, whereValue, whereValues, _depth, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _nb_feats, _ref, _ref1, _ref2, _ref3;
      this._debug("reduceFn(requests, features)" + " // deep comparison".grey);
      if (features == null) {
        this._debug("reduceFn: end condition");
        return requests;
      }
      for (_i = 0, _len = requests.length; _i < _len; _i++) {
        request = requests[_i];
        weight = 0;
        factors = [];
        nb_feats = 0;
        _ref = request.query.where;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          where = _ref[_j];
          depth = 0;
          complexity = 0;
          for (_k = 0, _len2 = features.length; _k < _len2; _k++) {
            _ref1 = features[_k], type = _ref1[0], key = _ref1[1], value = _ref1[2];
            if (key in where) {
              whereValues = utils.isArray(where[key]) ? where[key] : [where[key]];
              match = false;
              for (_l = 0, _len3 = whereValues.length; _l < _len3; _l++) {
                whereValue = whereValues[_l];
                switch (type) {
                  case 'String':
                    value = "" + value;
                    whereValue = "" + whereValue;
                    if (__indexOf.call(value, ' ') >= 0 || __indexOf.call(whereValue, ' ') >= 0) {
                      _ref2 = text.distance(value, whereValue), _depth = _ref2[0], _nb_feats = _ref2[1];
                      depth += _depth;
                      nb_feats += _nb_feats;
                      match = true;
                    } else {
                      if (value === whereValue) {
                        depth += 1;
                        match = true;
                      }
                    }
                    break;
                  case 'Number':
                    whereValue = Number(whereValue);
                    if (!isNaN(whereValue) && isFinite(whereValue)) {
                      delta = Math.abs(value - whereValue);
                      depth += 1 / (1 + delta);
                      match = true;
                    }
                    break;
                  case 'Boolean':
                    if ((Boolean(value)) === (Boolean(whereValue))) {
                      depth += 1;
                      match = true;
                    }
                    break;
                  default:
                    this._debug("type " + type + " not supported");
                }
              }
              if (match) {
                nb_feats += 1;
              }
            }
          }
          depth *= Math.min(6, 300 / nb_feats);
          weight += Math.pow(10, Math.min(300, depth));
        }
        for (_m = 0, _len4 = features.length; _m < _len4; _m++) {
          _ref3 = features[_m], type = _ref3[0], key = _ref3[1], value = _ref3[2];
          if (request.query.select != null) {
            if (!(key in request.query.select)) {
              continue;
            }
          }
          if (!(key in request.types)) {
            request.types[key] = type;
          }
          if (!(key in request.result)) {
            request.result[key] = {};
          }
          if (!(value in request.result[key])) {
            request.result[key][value] = 0;
          }
          match = false;
          if (request.query.select != null) {
            if (utils.isArray(request.query.select[key])) {
              if (request.query.select[key].length) {
                if (__indexOf.call(request.query.select[key], value) >= 0) {
                  match = true;
                }
              } else {
                match = true;
              }
            } else {
              if (value === request.query.select[key]) {
                match = true;
              }
            }
          } else {
            match = true;
          }
          if (match) {
            request.result[key][value] += weight;
          }
        }
      }
      this._debug("_reduceFn: reducing");
      return requests;
    };

    Query.prototype._toBestFn = function(inputs, cb) {
      var best, input, isNumerical, key, option, options, output, outputs, query, result, sum, types, weight, ws;
      this._debug("_toBestFn(inputs)");
      outputs = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = inputs.length; _i < _len; _i++) {
          input = inputs[_i];
          result = input.result, types = input.types, query = input.query;
          output = {};
          for (key in result) {
            options = result[key];
            this._debug("_toBestFn: " + key + ": " + (pretty(options)));
            isNumerical = types[key] === 'Number';
            if (isNumerical) {
              sum = 0;
              for (option in options) {
                weight = options[option];
                sum += weight;
              }
              output[key] = 0;
              for (option in options) {
                weight = options[option];
                option = Number(option);
                if (sum > 0) {
                  ws = weight / sum;
                  output[key] += option * ws;
                } else {
                  output[key] += option * weight;
                }
              }
            } else {
              output[key] = [];
              for (option in options) {
                weight = options[option];
                if (types[key] === 'Boolean') {
                  option = Boolean(option);
                }
                output[key].push([option, weight]);
              }
              output[key].sort(function(a, b) {
                return b[1] - a[1];
              });
              output[key].slice(0, this._maxOptions);
              best = output[key][0];
              output[key] = best[0];
            }
          }
          _results.push({
            query: query,
            result: output,
            types: types
          });
        }
        return _results;
      }).call(this);
      if (cb != null) {
        cb(outputs);
        return void 0;
      } else {
        return outputs;
      }
    };

    Query.prototype._toAllFn = function(requests, cb) {
      var __toAllFn;
      this._debug("_toAllFn(requests, cb?)" + "  // cast output map to typed array");
      __toAllFn = (function(_this) {
        return function() {
          var key, option, options, request, sorted, weight, _i, _len, _ref;
          _this._debug("_toAllFn:__toAllFn()");
          for (_i = 0, _len = requests.length; _i < _len; _i++) {
            request = requests[_i];
            _ref = request.result;
            for (key in _ref) {
              options = _ref[key];
              sorted = [];
              if (request.types[key] === 'Number') {
                _this._debug("_toAllFn:__toAllFn: Number -> " + key);
                for (option in options) {
                  weight = options[option];
                  sorted.push([Number(option), weight]);
                }
              } else if (request.types[key] === 'Boolean') {
                _this._debug("_toAllFn:__toAllFn: Boolean -> " + key);
                for (option in options) {
                  weight = options[option];
                  sorted.push([Boolean(option), weight]);
                }
              } else {
                _this._debug("_toAllFn:__toAllFn: String -> " + key);
                for (option in options) {
                  weight = options[option];
                  sorted.push([option, weight]);
                }
              }
              sorted = sorted.sort(function(a, b) {
                return b[1] - a[1];
              });
              sorted = sorted.slice(0, _this._maxOptions);
              request.result[key] = sorted;
            }
            return;
          }
        };
      })(this);
      if (cb != null) {
        __toAllFn();
        cb(requests);
        return void 0;
      } else {
        __toAllFn();
        return requests;
      }
    };

    Query.prototype.trigger = function(cb) {
      if (cb != null) {
        return this._async(cb);
      } else {
        return this._sync();
      }
    };

    Query.prototype.all = function(cb) {
      this._debug("all(cb?)");
      this._mode = 'all';
      return this.trigger(cb);
    };

    Query.prototype.best = function(cb) {
      this._debug("mix(cb?)");
      this._mode = 'best';
      return this.trigger(cb);
    };

    Query.prototype.repair = function(cb) {
      this._debug("repair(cb?)");
      this._mode = 'repair';
      return this.trigger(cb);
    };

    Query.prototype.pick = function(n, cb) {
      this._debug("pick(" + n + ", cb?)");
      this._mode = 'pick';
      this._pick_instances = n;
      return this.trigger(cb);
    };

    Query.prototype.generate = function(cb) {
      this._debug("generate(cb?)");
      this._mode = 'generate';
      return this.trigger(cb);
    };

    Query.prototype._sync = function() {
      var firstRequest, i, k, key, option, options, output, picked, query, repaired, request, requests, res, results, v;
      this._debug("_sync()");
      if (!(this._queries.length > 0)) {
        throw "error, no query is empty";
      }
      requests = (function() {
        var _i, _len, _ref, _results;
        _ref = this._queries;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          query = _ref[_i];
          _results.push({
            query: query,
            result: {},
            types: {}
          });
        }
        return _results;
      }).call(this);
      this._debug("_sync: @_fussy.eachFeatureSync:");
      this._fussy.eachFeaturesSync((function(_this) {
        return function(features, isLastItem) {
          _this._debug("_sync: @_fussy.eachFeatureSync(" + (pretty(features)) + ", " + (pretty(isLastItem)) + ")");
          return requests = _this._reduceFn(requests, features);
        };
      })(this));
      output = (function() {
        switch (this._mode) {
          case 'all':
            this._debug("_sync: all: @_toAllFn()");
            return this._toAllFn(requests);
          case 'pick':
            this._debug("_sync: pick");
            res = (function() {
              var _i, _ref, _ref1, _results;
              _results = [];
              for (i = _i = 0, _ref = this._pick_instances; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                firstRequest = requests[0];
                picked = {};
                _ref1 = firstRequest.result;
                for (key in _ref1) {
                  options = _ref1[key];
                  option = deck.pick(options);
                  picked[key] = option;
                }
                _results.push(picked);
              }
              return _results;
            }).call(this);
            if (utils.isArray(res)) {
              if (res.length === 1) {
                res = res[0];
              }
            }
            return res;
          case 'generate':
            this._debug("_sync: generate");
            return (function(_this) {
              return function() {
                var generated, _ref;
                firstRequest = requests[0];
                generated = {};
                _ref = firstRequest.result;
                for (key in _ref) {
                  options = _ref[key];
                  generated[key] = deck.pick(options);
                }
                return generated;
              };
            })(this);
          case 'best':
            this._debug("_sync: best: @_toBestFn(" + (pretty(requests)) + ")");
            return this._toBestFn(requests);
          case 'repair':
            this._debug("_sync: fix: @_toBestFn(" + (pretty(requests)) + ")");
            results = this._toBestFn(requests);
            repaired = (function() {
              var _i, _len, _ref, _results;
              _results = [];
              for (_i = 0, _len = results.length; _i < _len; _i++) {
                request = results[_i];
                _ref = request.result;
                for (k in _ref) {
                  v = _ref[k];
                  if (request.query.repair[k] == null) {
                    request.query.repair[k] = v;
                  }
                }
                _results.push(request.query.repair);
              }
              return _results;
            })();
            return repaired;
        }
      }).call(this);
      this._debug("_sync: return " + (pretty(output)));
      return output;
    };

    Query.prototype.onError = function(cb) {
      this._debug("onError(cb)");
      return this._onError = cb;
    };

    Query.prototype._async = function(cb) {
      var query, requests;
      this._debug("_async(cb)");
      if (!(this._queries.length > 0)) {
        throw "error, no query is empty";
      }
      requests = (function() {
        var _i, _len, _ref, _results;
        _ref = this._queries;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          query = _ref[_i];
          _results.push({
            query: query,
            result: {},
            types: {}
          });
        }
        return _results;
      }).call(this);
      this._debug("_async: @_fussy.eachFeatureAsync:");
      this._fussy.eachFeaturesAsync((function(_this) {
        return function(features, isLastItem) {
          var firstRequest, i, key, option, options, picked, res, results;
          _this._debug("_async: @_fussy.eachFeatureAsync(" + (pretty(features)) + ", " + (pretty(isLastItem)) + ")");
          _this._debug("_async: @_reduceFn(requests, features)");
          results = _this._reduceFn(requests, features);
          if (!isLastItem) {
            return;
          }
          _this._debug("_async: isLastItem == true");
          switch (_this._mode) {
            case 'all':
              _this._debug("_async: all: @_toAllFn(requests, cb)");
              return _this._toAllFn(requests, function(results) {
                _this._debug("_async: all: cb(results)");
                return cb(results);
              });
            case 'pick':
              _this._debug("_sync: pick");
              res = (function() {
                var _i, _ref, _ref1, _results;
                _results = [];
                for (i = _i = 0, _ref = this._pick_instances; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                  firstRequest = requests[0];
                  picked = {};
                  _ref1 = firstRequest.result;
                  for (key in _ref1) {
                    options = _ref1[key];
                    option = deck.pick(options);
                    picked[key] = option;
                  }
                  _results.push(picked);
                }
                return _results;
              }).call(_this);
              if (utils.isArray(res)) {
                if (res.length === 1) {
                  res = res[0];
                }
              }
              return cb(res);
            case 'generate':
              _this._debug("_async: generate");
              return cb(function() {
                var generated, _ref;
                firstRequest = requests[0];
                generated = {};
                _ref = firstRequest.result;
                for (key in _ref) {
                  options = _ref[key];
                  generated[key] = deck.pick(options);
                }
                return generated;
              });
            case 'best':
              _this._debug("_async: best: @_toBestFn(" + (pretty(requests)) + ")");
              return _this._toBestFn(requests, function(bests) {
                _this._debug("_async: best: cb(bests)");
                return cb(bests);
              });
            case 'repair':
              _this._debug("_async: repair: @_toBestFn(" + (pretty(requests)) + ")");
              return _this._toBestFn(requests, function(results) {
                var k, repaired, request, v;
                _this._debug("_async: repair: @_toBestFn: results: " + (pretty(results)));
                repaired = (function() {
                  var _i, _len, _ref, _results;
                  _results = [];
                  for (_i = 0, _len = results.length; _i < _len; _i++) {
                    request = results[_i];
                    _ref = request.result;
                    for (k in _ref) {
                      v = _ref[k];
                      if (request.query.repair[k] == null) {
                        request.query.repair[k] = v;
                      }
                    }
                    _results.push(request.query.repair);
                  }
                  return _results;
                })();
                return cb(repaired);
              });
          }
        };
      })(this));
      return void 0;
    };

    return Query;

  })();

  module.exports = Query;

}).call(this);
