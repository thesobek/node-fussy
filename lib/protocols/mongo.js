// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var Mongo, Url, colors, csvString, mime, pretty, util, utils;

  util = require('util');

  Url = require('url');

  mime = require('mime');

  colors = require('colors');

  csvString = require('csv-string');

  utils = require('../utils');

  pretty = utils.pretty;


  /*
  for repair() and batch processing, we might want to use this:
  https://www.npmjs.org/package/mongo-writable-stream
   */

  Mongo = (function() {
    function Mongo(_fussy, _url) {
      var parsed, path, _ref, _ref1, _ref2;
      this._fussy = _fussy;
      this._url = _url;
      parsed = Url.parse(this._url);
      this._host = (_ref = parsed.hostname) != null ? _ref : '127.0.0.1';
      this._port = Number((_ref1 = parsed.port) != null ? _ref1 : '27017');
      path = ((_ref2 = parsed.path) != null ? _ref2 : '/fussy/fussy').split('/');
      this._database = path[1];
      this._collection = path[2];
      this._batchSize = 1024;
    }

    Mongo.prototype.debug = function(enabled) {
      this._debugEnabled = enabled;
      return this;
    };

    Mongo.prototype._debug = function(x) {
      if (!(this._debugEnabled != null ? this._debugEnabled : this._fussy._debugEnabled)) {
        return;
      }
      return console.log("Mongo".blue + "::".grey + x);
    };

    Mongo.prototype.eachSync = function(cb) {
      var Server, cursor, db, i, item, limit, results, size, skip, _i, _len;
      this._debug('eachSync');
      throw "eachSync not supported for Mongo protocol";
      limit = this._fussy.limit();
      skip = this._fussy.skip();
      Server = require('mongo-sync').Server;
      db = new Server(this._host);
      this._debug("eachSync: gettin cursor on database and collection");
      cursor = db.db(this._database).getCollection(this._collection).find();
      if (skip != null) {
        this._debug("eachSync: skipping " + skip + " results of collection");
        cursor = cursor.skip(skip);
      }
      if (limit != null) {
        this._debug("eachSync: limiting " + limit + " results of collection");
        cursor = cursor.limit(limit);
      }
      results = cursor.toArray();
      i = 0;
      size = results.length;
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        item = results[_i];
        cb(item, false);
      }
      cb(void 0, true);
      db.close();
      return void 0;
    };

    Mongo.prototype.eachAsync = function(cb) {
      var MongoClient, collection, delay, limit, opts, skip;
      this._debug("eachAsync:");
      MongoClient = require('mongodb').MongoClient;
      collection = this._collection;
      limit = this._fussy.limit();
      skip = this._fussy.skip();
      delay = 0;
      this._debug("eachAsync: connecting to mongo (" + this._host + ":" + this._port + ")/" + (pretty(this._database)));
      opts = {
        db: {
          native_parser: true
        }
      };
      MongoClient.connect("mongodb://" + this._host + ":" + this._port + "/" + this._database, opts, (function(_this) {
        return function(err, db) {
          var cursor, _readCursor;
          _this._debug("err: " + (pretty(err)));
          if (err) {
            throw err;
          }
          _this._debug("eachAsync: gettin cursor on database and collection");
          cursor = db.collection(collection).find();
          if (skip != null) {
            _this._debug("eachAsync: skipping " + skip + " results of collection");
            cursor = cursor.skip(skip);
          }
          if (limit != null) {
            _this._debug("eachAsync: limiting " + limit + " results of collection");
            cursor = cursor.limit(limit);
          }
          cursor = cursor.batchSize(_this._batchSize);
          _readCursor = function(i) {
            return cursor.nextObject(function(err, item) {
              var fn;
              _this._debug("eachAsync._readCursor: cursor.nextObject (" + err + ", " + (pretty(item)) + ")");
              if (err) {
                throw err;
              }
              if (item) {
                _this._debug("                          - returned an item");
                cb(item, false);
                fn = function() {
                  return _readCursor(i + 1);
                };
                return setTimeout(fn, delay);
              } else {
                _this._debug("                          - returned nothing: end reached");
                cb(void 0, true);
                return db.close();
              }
            });
          };
          _this._debug("eachAsync: _readCursor(cursor, 0, delay, db, next)");
          return _readCursor(0);
        };
      })(this));
      return void 0;
    };

    return Mongo;

  })();

  module.exports = Mongo;

}).call(this);
