// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var File, Url, colors, csvString, fs, mime, path, pretty, util, utils;

  path = require('path');

  util = require('util');

  Url = require('url');

  fs = require('fs');

  mime = require('mime');

  colors = require('colors');

  csvString = require('csv-string');

  utils = require('../utils');

  pretty = utils.pretty;

  File = (function() {
    function File(_fussy, _url) {
      var parsed;
      this._fussy = _fussy;
      this._url = _url;
      parsed = Url.parse(this._url);
      this._path = parsed.path;
      if (parsed.protocol == null) {
        this._path = this._url;
      }
      this._mimetype = mime.lookup(this._path);
    }

    File.prototype.debug = function(enabled) {
      this._debugEnabled = enabled;
      return this;
    };

    File.prototype._debug = function(x) {
      if (!(this._debugEnabled != null ? this._debugEnabled : this._fussy._debugEnabled)) {
        return;
      }
      return console.log("File".blue + "::".grey + x);
    };

    File.prototype.eachSync = function(cb) {
      var limit, line, lines, skip, str, _i, _len, _ref, _ref1, _ref2;
      this._debug("eachSync(cb)");
      if (this._mimetype !== 'text/csv') {
        throw "files of type " + this._mimetype + " are not supported in synchronous mode";
      }
      str = fs.readFileSync(this._path, 'utf8');
      lines = str.split('\n');
      skip = (_ref = this._fussy._skip) != null ? _ref : 0;
      limit = (_ref1 = this._fussy._limit) != null ? _ref1 : Infinity;
      _ref2 = lines.slice(skip, skip + limit);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        line = _ref2[_i];
        cb(line, false);
      }
      cb(void 0, true);
    };

    File.prototype.eachAsync = function(cb) {
      var instream, limit, skip, _readInputStream, _ref, _ref1;
      this._debug("eachAsync(cb)");
      skip = (_ref = this._fussy._skip) != null ? _ref : 0;
      limit = (_ref1 = this._fussy._limit) != null ? _ref1 : Infinity;
      _readInputStream = (function(_this) {
        return function(instream, cb) {
          var i, outstream, rl;
          outstream = new (require('stream'));
          rl = require('readline').createInterface(instream, outstream);
          i = 0;
          rl.on('line', function(line) {
            i += 1;
            if (i <= skip) {
              return;
            }
            if (i < (skip + limit)) {
              return cb(line, false);
            } else {
              return this.debug("todo: stop read stream");
            }
          });
          return rl.on('close', function() {
            return cb(void 0, true);
          });
        };
      })(this);
      switch (this._mimetype) {
        case 'application/zip':
          this._debug("eachAsync: opening " + this._mimetype + " file");
          fs.createReadStream(this._path).pipe(unzip.Parse()).on('entry', (function(_this) {
            return function(entry) {
              var type;
              _this._debug("eachAsync: inside the " + _this._mimetype + " I found this: " + entry.path);
              if (entry.type === 'File') {
                type = mime.lookup(entry.path);
                switch (type) {
                  case 'text/csv':
                    _this._debug("eachAsync: inside the " + _this._mimetype + " I found some " + type);
                    _readInputStream(entry, cb);
                    return;
                }
              }
              _this._debug("eachAsync: ignoring file " + entry.path + " by draining the input stream");
              return entry.autodrain();
            };
          })(this));
          break;
        case 'text/csv':
          this._debug("eachAsync: reading text/csv file");
          instream = fs.createReadStream(this._path);
          _readInputStream(instream, cb);
          break;
        default:
          thro("files of type " + this._mimetype + " are not supported in asynchronous mode");
      }
      return void 0;
    };

    return File;

  })();

  module.exports = File;

}).call(this);
