// Generated by CoffeeScript 1.7.1
(function() {
  var File, Fussy, Lazy, Mongo, Query, Url, colors, csv, debug, debugEnabled, detach, extract, mime, path, pretty, unzip, util, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  path = require('path');

  util = require('util');

  Url = require('url');

  Lazy = require('lazy.js');

  unzip = require('unzip');

  mime = require('mime');

  colors = require('colors');

  csv = require('ya-csv');

  utils = require('./utils');

  extract = require('./extract');

  pretty = utils.pretty;

  debugEnabled = false;

  debug = function(x) {
    if (!debugEnabled) {
      return;
    }
    return console.log(x);
  };

  detach = function(f) {
    return setTimeout(f, 0);
  };

  Query = (function() {
    function Query(db, q) {
      var select, tmp, _i, _len, _ref;
      this._error = void 0;
      this._mode = 'all';
      if (q.select != null) {
        if (utils.isString(q.select)) {
          tmp = {};
          tmp[q.select] = [];
          q.select = tmp;
        } else if (utils.isArray(q.select)) {
          tmp = {};
          _ref = q.select;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            select = _ref[_i];
            tmp[select] = [];
          }
          q.select = tmp;
        }
      }
      if (!utils.isArray(q.where)) {
        q.where = [q.where];
      }
      this._db = db;
      this._query = q;
    }

    Query.prototype.debug = function(enabled) {
      if (enabled == null) {
        return debugEnabled;
      }
      debug("Query".yellow + "::debug(value) " + " // setting debug to ".grey + ("" + (pretty(enabled))));
      debugEnabled = enabled;
      return this;
    };

    Query.prototype._reduceFn = function(reduction, features) {
      var complexity, delta, depth, factors, key, match, nb_feats, query, type, value, weight, where, whereValue, whereValues, _depth, _i, _j, _k, _l, _len, _len1, _len2, _len3, _nb_feats, _ref, _ref1, _ref2, _ref3;
      debug("Query".green + "::reduceFn(reduction, features)" + " // deep comparison".grey);
      if (features == null) {
        debug("Query".green + "::reduceFn: end condition");
        return reduction;
      }
      query = reduction.query;
      weight = 0;
      factors = [];
      nb_feats = 0;
      _ref = query.where;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        where = _ref[_i];
        depth = 0;
        complexity = 0;
        for (_j = 0, _len1 = features.length; _j < _len1; _j++) {
          _ref1 = features[_j], type = _ref1[0], key = _ref1[1], value = _ref1[2];
          if (key in where) {
            whereValues = utils.isArray(where[key]) ? where[key] : [where[key]];
            match = false;
            for (_k = 0, _len2 = whereValues.length; _k < _len2; _k++) {
              whereValue = whereValues[_k];
              switch (type) {
                case 'String':
                  value = "" + value;
                  whereValue = "" + whereValue;
                  if (__indexOf.call(value, ' ') >= 0 || __indexOf.call(whereValue, ' ') >= 0) {
                    _ref2 = text.distance(value, whereValue), _depth = _ref2[0], _nb_feats = _ref2[1];
                    depth += _depth;
                    nb_feats += _nb_feats;
                    match = true;
                  } else {
                    if (value === whereValue) {
                      depth += 1;
                      match = true;
                    }
                  }
                  break;
                case 'Number':
                  whereValue = Number(whereValue);
                  if (!isNaN(whereValue) && isFinite(whereValue)) {
                    delta = Math.abs(value - whereValue);
                    depth += 1 / (1 + delta);
                    match = true;
                  }
                  break;
                case 'Boolean':
                  if ((Boolean(value)) === (Boolean(whereValue))) {
                    depth += 1;
                    match = true;
                  }
                  break;
                default:
                  debug("type " + type + " not supported");
              }
            }
            if (match) {
              nb_feats += 1;
            }
          }
        }
        depth *= Math.min(6, 300 / nb_feats);
        weight += Math.pow(10, Math.min(300, depth));
      }
      for (_l = 0, _len3 = features.length; _l < _len3; _l++) {
        _ref3 = features[_l], type = _ref3[0], key = _ref3[1], value = _ref3[2];
        if (query.select != null) {
          if (!(key in query.select)) {
            continue;
          }
        }
        if (!(key in reduction.types)) {
          reduction.types[key] = type;
        }
        if (!(key in reduction.result)) {
          reduction.result[key] = {};
        }
        if (!(value in reduction.result[key])) {
          reduction.result[key][value] = 0;
        }
        match = false;
        if (query.select != null) {
          if (utils.isArray(query.select[key])) {
            if (query.select[key].length) {
              if (__indexOf.call(query.select[key], value) >= 0) {
                match = true;
              }
            } else {
              match = true;
            }
          } else {
            if (value === query.select[key]) {
              match = true;
            }
          }
        } else {
          match = true;
        }
        if (match) {
          reduction.result[key][value] += weight;
        }
      }
      debug("Query".green + "::_reduceFn: reducing");
      return reduction;
    };

    Query.prototype._sortFn = function(input, cb) {
      var output;
      debug("Query".green + "::_sortFn(input, cb?)" + " // sort options by probability".grey);
      output = input.sort(function(a, b) {
        return b[2] - a[2];
      });
      if (cb != null) {
        cb(output);
        return void 0;
      } else {
        return output;
      }
    };

    Query.prototype._toBestFn = function(args) {
      var best, isNumerical, key, option, options, output, result, sum, types, weight;
      debug("Query".green + "::_toBestFn(args)");
      result = args.result, types = args.types;
      output = {};
      for (key in result) {
        options = result[key];
        isNumerical = types[key] === 'Number';
        if (utils.isNumerical) {
          sum = 0;
          for (option in options) {
            weight = options[option];
            sum += weight;
          }
          output[key] = 0;
          for (option in options) {
            weight = options[option];
            option = Number(option);
            output[key] += option * (weight / sum);
          }
        } else {
          output[key] = [];
          for (option in options) {
            weight = options[option];
            if (types[key] === 'Boolean') {
              option = Boolean(option);
            }
            output[key].push([option, weight]);
          }
          output[key].sort(function(a, b) {
            return b[1] - a[1];
          });
          best = output[key][0];
          output[key] = best[0];
        }
      }
      if (typeof cb !== "undefined" && cb !== null) {
        cb(output);
        return void 0;
      } else {
        return output;
      }
    };

    Query.prototype._toAllFn = function(args, cb) {
      var result, __toAllFn;
      debug("Query".green + "::_toAllFn(args, cb?)" + "  // cast output map to typed array");
      __toAllFn = function(args) {
        var key, option, options, res, weight, _ref, _results;
        debug("Query".green + ("::_toAllFn:__toAllFn(" + (pretty(args)) + ")"));
        res = {};
        _ref = args.result;
        _results = [];
        for (key in _ref) {
          options = _ref[key];
          _results.push(res[key] = (function() {
            var _results1, _results2, _results3;
            if (args.types[key] === 'Number') {
              debug("Query".green + ("::_toAllFn:__toAllFn: Number -> " + key));
              _results1 = [];
              for (option in options) {
                weight = options[option];
                _results1.push([key, Number(option, weight)]);
              }
              return _results1;
            } else if (args.types[key] === 'Boolean') {
              debug("Query".green + ("::_toAllFn:__toAllFn: Boolean -> " + key));
              _results2 = [];
              for (option in options) {
                weight = options[option];
                _results2.push([key, Boolean(option, weight)]);
              }
              return _results2;
            } else {
              debug("Query".green + ("::_toAllFn:__toAllFn: String -> " + key));
              _results3 = [];
              for (option in options) {
                weight = options[option];
                _results3.push([key, option, weight]);
              }
              return _results3;
            }
          })());
        }
        return _results;
      };
      if (cb != null) {
        result = __toAllFn(args);
        cb(result);
        return void 0;
      } else {
        result = __toAllFn(args);
        return result;
      }
    };

    Query.prototype.all = function(cb) {
      debug("Query".green + "::all(cb?)");
      this._mode = 'all';
      if (cb != null) {
        return this._async(cb);
      } else {
        return this._sync();
      }
    };

    Query.prototype.best = function(cb) {
      debug("Query".green + "::mix(cb?)");
      this._mode = 'best';
      if (cb != null) {
        return this._async(cb);
      } else {
        return this._sync();
      }
    };

    Query.prototype.replace = function(cb) {
      debug("Query".green + "::replace(cb?)");
      this._mode = 'replace';
      if (cb != null) {
        return this._async(cb);
      } else {
        return this._sync();
      }
    };

    Query.prototype._sync = function() {
      var ctx, k, obj, result, results, v;
      debug("Query".green + "::_sync()");
      ctx = {
        reduction: {
          query: this._query,
          result: {},
          types: {}
        }
      };
      debug("Query".green + "::_sync: @_db.eachFeatureSync:");
      this._db.eachFeaturesSync((function(_this) {
        return function(features, isLastItem) {
          debug("Query".green + ("::_sync: @_db.eachFeatureSync(" + (pretty(features)) + ", " + (pretty(isLastItem)) + ")"));
          return ctx.reduction = _this._reduceFn(ctx.reduction, features);
        };
      })(this));
      results = (function() {
        switch (this._mode) {
          case 'all':
            debug("Query".green + ("::_sync: all: @_toAllFn(" + (pretty(ctx.reduction)) + ")"));
            results = this._toAllFn(ctx.reduction);
            return this._sortFn(results);
          case 'best':
            debug("Query".green + ("::_sync: best: @_toBestFn(" + (pretty(ctx.reduction)) + ")"));
            return this._toBestFn(ctx.reduction);
          case 'replace':
            debug("Query".green + ("::_sync: fix: @_toBestFn(" + (pretty(ctx.reduction)) + ")"));
            result = this._toBestFn(ctx.reduction);
            obj = ctx.reduction.query.replace;
            for (k in result) {
              v = result[k];
              if (obj[k] == null) {
                obj[k] = v;
              }
            }
            return obj;
        }
      }).call(this);
      debug("Query".green + ("::_sync: return " + (pretty(results))));
      return results;
    };

    Query.prototype.onError = function(cb) {
      debug("Query".green + "::onError(cb)");
      return this._onError = cb;
    };

    Query.prototype._async = function(cb) {
      var ctx;
      debug("Query".green + "::_async(cb)");
      ctx = {
        reduction: {
          query: this._query,
          result: {},
          types: {}
        }
      };
      debug("Query".green + "::_async: @_db.eachFeatureAsync:");
      this._db.eachFeaturesAsync((function(_this) {
        return function(features, isLastItem) {
          var results;
          debug("Query".green + ("::_async: @_db.eachFeatureAsync(" + (pretty(features)) + ", " + (pretty(isLastItem)) + ")"));
          debug("Query".green + "::_async: @_reduceFn(ctx.reduction, features)");
          ctx.reduction = _this._reduceFn(ctx.reduction, features);
          if (!isLastItem) {
            return;
          }
          debug("Query".green + "::_async: isLastItem == true");
          return results = (function() {
            switch (this._mode) {
              case 'all':
                debug("Query".green + "::_async: all: @_toAllFn(ctx.reduction, cb)");
                return this._toAllFn(ctx.reduction, (function(_this) {
                  return function(results) {
                    debug("Query".green + "::_async: all: @_sortFn(results, cb)");
                    return _this._sortFn(results, function(results) {
                      debug("Query".green + "::_async: all: cb(results)");
                      return cb(results);
                    });
                  };
                })(this));
              case 'best':
                debug("Query".green + ("::_async: best: @_toBestFn(" + (pretty(ctx.reduction)) + ")"));
                return this._toBestFn(ctx.reduction, (function(_this) {
                  return function(best) {
                    debug("Query".green + "::_async: best: cb(results)");
                    return cb(results);
                  };
                })(this));
              case 'fix':
                debug("Query".green + ("::_async: fix: @_toBestFn(" + (pretty(ctx.reduction)) + ")"));
                return this._toBestFn(ctx.reduction, (function(_this) {
                  return function(best) {
                    var k, obj, v;
                    obj = ctx.reduction.query.replace;
                    for (k in result) {
                      v = result[k];
                      if (obj[k] == null) {
                        obj[k] = v;
                      }
                    }
                    obj;
                    return cb(obj);
                  };
                })(this));
            }
          }).call(_this);
        };
      })(this));
      return void 0;
    };

    return Query;

  })();

  File = (function() {
    function File(_fussy, _url) {
      var parsed;
      this._fussy = _fussy;
      this._url = _url;
      parsed = Url.parse(this._url);
      this._path = parsed.path;
      if (parsed.protocol == null) {
        this._path = this._url;
      }
    }

    File.prototype.eachSync = function(cb) {
      var fs, i, line, lines, str, _i, _len;
      debug("File".blue + "::eachSync(cb)");
      fs = require('fs');
      str = fs.readFileSync(this._path, 'utf-8');
      lines = str.split('\n');
      i = 0;
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        cb(line, false);
        i += 1;
      }
      return cb(void 0, true);
    };

    File.prototype.eachAsync = function(cb) {
      var fs, i, instream, outstream, readline, rl, stream;
      debug("File".blue + "::eachAsync(cb)");
      fs = require('fs');
      readline = require('readline');
      stream = require('stream');
      instream = fs.createReadStream(this._path);
      outstream = new stream;
      rl = readline.createInterface(instream, outstream);
      i = 0;
      rl.on('line', function(line) {
        cb(line, false);
        return i += 1;
      });
      rl.on('close', function() {
        return cb(void 0, true);
      });
      return void 0;
    };

    return File;

  })();

  Mongo = (function() {
    function Mongo(_fussy, _url) {
      var parsed, _ref, _ref1, _ref2;
      this._fussy = _fussy;
      this._url = _url;
      parsed = Url.parse(this._url);
      this._host = (_ref = parsed.hostname) != null ? _ref : '127.0.0.1';
      this._port = Number((_ref1 = parsed.port) != null ? _ref1 : '27017');
      path = (_ref2 = parsed.path) != null ? _ref2 : '/fussy/fussy';
      this._database = path[0];
      this._collection = path[1];
      this._batchSize = 1024;
    }

    Mongo.prototype.eachSync = function(cb) {
      var Server, cursor, db, i, item, limit, results, size, skip, _i, _len;
      debug('Mongo::eachSync');
      limit = this._fussy.limit();
      skip = this._fussy.skip();
      Server = require('mongo-sync').Server;
      db = new Server(this._host);
      debug("Mongo".blue + "::eachSync: gettin cursor on database and collection");
      cursor = db.db(this._database).getCollection(this._collection).find();
      if (skip != null) {
        debug("Mongo".blue + ("::eachSync: skipping " + skip + " results of collection"));
        cursor = cursor.skip(skip);
      }
      if (limit != null) {
        debug("Mongo".blue + ("::eachSync: limiting " + limit + " results of collection"));
        cursor = cursor.limit(limit);
      }
      results = cursor.toArray();
      i = 0;
      size = results.length;
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        item = results[_i];
        cb(item, false);
      }
      cb(void 0, true);
      db.close();
      return void 0;
    };

    Mongo.prototype.eachAsync = function(cb) {
      var MongoClient, collection, delay, limit, skip;
      debug("Mongo".blue + "::eachAsync(cb)");
      MongoClient = require('mongodb').MongoClient;
      collection = this._collection;
      limit = this._fussy.limit();
      skip = this._fussy.skip();
      delay = 0;
      debug("Mongo".blue + ("::eachAsync: connecting to mongo (" + this._host + ":" + this._port + ")"));
      MongoClient.connect("mongodb://" + this._host + ":" + this._port + "/" + _database, function(err, db) {
        var cursor, _readCursor;
        if (err) {
          throw err;
        }
        debug("Mongo".blue + "::eachAsync: gettin cursor on database and collection");
        cursor = db.collection(collection).find();
        if (skip != null) {
          debug("Mongo".blue + ("::eachSync: skipping " + skip + " results of collection"));
          cursor = cursor.skip(skip);
        }
        if (limit != null) {
          debug("Mongo".blue + ("::eachSync: limiting " + limit + " results of collection"));
          cursor = cursor.limit(limit);
        }
        cursor = cursor.batchSize(this._batchSize);
        _readCursor = function(cursor, i, delay, db, next) {
          return cursor.nextObject(function(err, item) {
            var fn;
            debug("Mongo".blue + "::eachAsync:_readCursor: cursor.nextObject(function(err, item){})");
            if (err) {
              throw err;
            }
            if (item) {
              debug("                          - returned an item");
              cb(item, true);
              fn = function() {
                return next(cursor, i + 1, delay);
              };
              return setTimeout(fn, delay);
            } else {
              debug("                          - returned nothing: end reached");
              cb(void 0, true);
              return db.close();
            }
          });
        };
        debug("Mongo".blue + "::eachAsync: calling _readCursor(cursor, 0, delay, db, next)");
        return _readCursor(cursor, 0, delay, db, _readCursor);
      });
      return void 0;
    };

    return Mongo;

  })();

  Fussy = (function() {
    function Fussy(input) {
      this.eachFeaturesAsync = __bind(this.eachFeaturesAsync, this);
      var parsed;
      this._skip = void 0;
      this._limit = void 0;
      parsed = Url.parse(input);
      switch (parsed.protocol) {
        case 'rest:':
        case 'http:':
        case 'http+rest:':
        case 'http+json':
        case 'https:':
        case 'https+rest:':
        case 'https+json':
          debug("Fussy".yellow + "::constructor: protocol is http rest");
          throw "http rest protocol is not supported yet";
          break;
        case 'file:':
        case 'file+csv:':
        case 'file+json:':
        case 'file+txt:':
          debug("Fussy".yellow + "::constructor: protocol is file");
          this._engine = new File(this, input);
          break;
        case 'mongo:':
        case 'mongodb:':
          debug("Fussy".yellow + "::constructor: protocol is MongoDB");
          this._engine = new Mongo(this, input);
          break;
        default:
          debug("Fussy".yellow + "::constructor: protocol is default (file)");
          this._engine = new File(this, input);
      }
    }

    Fussy.prototype._parse = function(input) {
      var exc, output;
      output = void 0;
      if (this._schema != null) {
        debug("Fussy".yellow + "::_parse: using schema");
        if (utils.isString(input)) {
          try {
            output = utils.parse(this._schema, input);
          } catch (_error) {
            exc = _error;
            debug("Fussy".yellow + "::_parse: couldn't parse input, trying to parse json from string");
            try {
              output = JSON.parse(input);
            } catch (_error) {
              exc = _error;
              debug("Fussy".yellow + "::_parse: couldn't parse json input. I could use the object as is, but since you defined a schema I prefer to skip it");
              output = void 0;
            }
          }
        } else {
          output = input;
        }
      } else if (utils.isString(input)) {
        debug("Fussy".yellow + "::_parse: no schema, trying to parse json from string");
        output = JSON.parse(input);
      } else {
        debug("Fussy".yellow + "::_parse: no schema, using js object as-is");
        output = input;
      }
      debug("Fussy".yellow + ("::_parse: " + (pretty(input)) + " =====> " + (pretty(output))));
      return output;
    };

    Fussy.prototype._extract = function(event, facts, prefix) {
      var exc, key, value;
      if (facts == null) {
        facts = [];
      }
      if (prefix == null) {
        prefix = "";
      }
      debug("Fussy".yellow + "::_extract(event)");

      /*
      This was supposed to be a built-in support for a "date" attribute
      TODO but it is a bit awkward: we should rather use the schema for that.
      let's disable it for now.
       */
      try {
        for (key in event) {
          value = event[key];
          key = prefix + key;
          if (utils.isString(value)) {
            facts.push(['String', key, value]);
          } else if (utils.isArray(value)) {
            facts.push(['Array', key, value]);
          } else if (utils.isNumber(value)) {
            facts.push(['Number', key, value]);
          } else if (utils.isBoolean(value)) {
            facts.push(['Boolean', key, value]);
          } else {
            this._extract(value, facts, key + ".");
          }
        }
      } catch (_error) {
        exc = _error;
        console.log("failed: " + exc);
        console.log(exc);
      }
      return facts;
    };

    Fussy.prototype.schema = function(schema) {
      if (schema == null) {
        throw "cannot set an undefined schema";
      }
      this._schema = utils.loadSchema(schema);
      return this;
    };

    Fussy.prototype.limit = function(limit) {
      if (limit == null) {
        return this._limit;
      }
      if (limit < 0) {
        throw "limit must be >= 0";
      }
      debug("Fussy".yellow + "::limit(value) " + " // setting limit to ".grey + ("" + (pretty(limit))));
      this._limit = limit;
      return this;
    };

    Fussy.prototype.skip = function(skip) {
      if (skip == null) {
        return this._skip;
      }
      if (skip < 0) {
        throw "skip must be >= 0";
      }
      debug("Fussy".yellow + "::skip(value) " + " // setting skip to ".grey + ("" + (pretty(skip))));
      this._skip = skip;
      return this;
    };

    Fussy.prototype.debug = function(enabled) {
      if (enabled == null) {
        return debugEnabled;
      }
      debug("Fussy".yellow + "::debug(value) " + " // setting debug to ".grey + ("" + (pretty(enabled))));
      debugEnabled = enabled;
      return this;
    };


    /*
    Call a function on each item, synchronously
    (the function will only returns once all items have been read)
    This functions skips invalid items
     */

    Fussy.prototype.eachFeaturesSync = function(cb) {
      debug("Fussy".yellow + "::eachFeaturesSync(cb)");
      return this._engine.eachSync((function(_this) {
        return function(item, eof) {
          var extracted, features;
          debug("Fussy".green + ("::eachFeaturesSync: @_engine.eachSync (item=" + (pretty(item)) + ", eof=" + (pretty(eof)) + ")"));
          if (eof) {
            cb(void 0, eof);
            return;
          }
          extracted = _this._parse(item);
          if (!extracted) {
            return;
          }
          features = _this._extract(extracted);
          if (!features) {
            return;
          }
          return cb(features, eof);
        };
      })(this));
    };


    /*
    Call a function on each item, asynchronously
     */

    Fussy.prototype.eachFeaturesAsync = function(cb) {
      return detach((function(_this) {
        return function() {
          debug("Fussy".yellow + "::eachFeaturesAsync(cb)");
          return _this._engine.eachAsync(function(item, eof) {
            var extracted, features;
            debug("Fussy".green + ("::eachFeaturesAsync: @_engine.eachAsync (item=" + (pretty(item)) + ", eof=" + (pretty(eof)) + ")"));
            if (eof) {
              cb(void 0, eof);
              return;
            }
            extracted = _this._parse(item);
            if (!extracted) {
              return;
            }
            features = _this._extract(extracted);
            if (!features) {
              return;
            }
            return cb(features, eof);
          });
        };
      })(this));
    };

    Fussy.prototype.onComplete = function(onCompleteCb) {
      debug("Fussy".yellow + "::_onCompleteCb = onCompleteCb");
      this._onCompleteCb = onCompleteCb;
      return this;
    };

    Fussy.prototype.query = function(query) {
      return new Query(this, query);
    };


    /*
    Repair an object in-place
    Only fields that are undefined will be filled, others will be left untouched
     */

    Fussy.prototype.repair = function(obj, cb) {
      var query;
      query = new Query(this, {
        replace: obj,
        select: Object.keys(obj),
        where: (function() {
          var key, newObj, _i, _len, _ref;
          newObj = {};
          _ref = Object.keys(obj);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            if (obj[key] != null) {
              newObj[key] = obj[key];
            }
          }
          return newObj;
        })()
      });
      return query.replace(cb);
    };

    Fussy.prototype.solve = function(obj, cb) {
      var query;
      query = new Query(this, {
        select: Object.keys(obj),
        where: (function() {
          var key, newObj, _i, _len, _ref;
          newObj = {};
          _ref = Object.keys(obj);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            if (obj[key] != null) {
              newObj[key] = obj[key];
            }
          }
          return newObj;
        })()
      });
      return query.best();
    };

    return Fussy;

  })();

  module.exports = {
    debug: function(enabled) {
      debugEnabled = enabled;
      return this;
    },
    pretty: utils.pretty,
    pperf: utils.pperf,
    pstats: utils.pstats,
    input: function(input) {
      return new Fussy(input);
    }
  };

}).call(this);
