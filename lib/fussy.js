// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var File, Fussy, Glob, Http, List, Mongo, NOOP, Query, Url, colors, csvString, pretty, utils;

  Url = require('url');

  colors = require('colors');

  csvString = require('csv-string');

  utils = require('./utils');

  List = require('./protocols/list');

  File = require('./protocols/file');

  Glob = require('./protocols/glob');

  Http = require('./protocols/http');

  Mongo = require('./protocols/mongo');

  Query = require('./query');

  pretty = utils.pretty;

  NOOP = void 0;

  Fussy = (function() {
    function Fussy(input, _debugEnabled) {
      var parsed;
      this._debugEnabled = _debugEnabled;
      this._skip = void 0;
      this._limit = void 0;
      this._maps = [];
      this._firstLine = true;
      this._custom_schema = false;
      if (utils.isArray(input)) {
        this._engine = new List(this, input);
      } else if (utils.isString(input)) {
        parsed = Url.parse(input);
        switch (parsed.protocol) {
          case 'rest:':
          case 'http:':
          case 'http+rest:':
          case 'http+json':
          case 'https:':
          case 'https+rest:':
          case 'https+json':
            this._debug("constructor: protocol is http rest");
            this._engine(new Http(this, input));
            break;
          case 'file:':
          case 'file+csv:':
          case 'file+json:':
          case 'file+txt:':
            this._debug("constructor: protocol is file");
            if (parsed.path.slice(-1) === '/' || parsed.path.match(/\*/)) {
              this._engine = new Glob(this, input);
            } else {
              this._engine = new File(this, input);
            }
            break;
          case 'mongo:':
          case 'mongodb:':
            this._debug("constructor: protocol is MongoDB");
            this._engine = new Mongo(this, input);
            break;
          default:
            this._debug("constructor: protocol is default (file)");
            if (parsed.path.slice(-1) === '/' || parsed.path.match(/\*/)) {
              this._engine = new Glob(this, input);
            } else {
              this._engine = new File(this, input);
            }
        }
      } else {
        throw "unsupported input type";
      }
    }

    Fussy.prototype.debug = function(enabled) {
      this._debugEnabled = enabled;
      return this;
    };


    /*
    define a map function
    a map take the object as argument, and must return another object
    if you return undefined, then the object will be taken out of the flow
    for all successive operations
     */

    Fussy.prototype.map = function(fn) {
      this._maps.push(fn);
      return this;
    };


    /*
    iterate over each object
    the return value of the iterator is ignored
     */

    Fussy.prototype.each = function(fn) {
      this._maps.push(function(obj) {
        fn(obj);
        return obj;
      });
      return this;
    };


    /*
    filter the stream using a condition
     */

    Fussy.prototype.filter = function(condition) {
      this._maps.push(function(obj) {
        if (condition(obj)) {
          return obj;
        } else {
          return void 0;
        }
      });
      return this;
    };


    /*
    removes null fields, empty strings, NaN..
     */

    Fussy.prototype.clean = function() {
      this._maps.push(function(obj) {
        var key, value, _i, _len, _ref;
        _ref = Object.keys(obj);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          value = obj[key];
          if (value === null) {
            delete obj[key];
          } else if (utils.isString(value)) {
            if (value.length < 1) {
              delete obj[key];
            } else if (value.match(/^(\\r|\\n)$/)) {
              delete obj[key];
            }
          }
          if (utils.isNumber(value)) {
            if (isNaN(value) || !isFinite(value)) {
              delete obj[key];
            }
          }
        }
        return obj;
      });
      return this;
    };

    Fussy.prototype._debug = function(x) {
      if (!this._debugEnabled) {
        return;
      }
      return console.log("Fussy".yellow + "::".grey + x);
    };


    /*
     */

    Fussy.prototype._parse = function(input) {
      var col, exc, exc2, i, inputIsProbablyHeader, item, k, output, tmp, type, v, value, _i, _j, _len, _len1, _ref;
      output = input;
      if (this._schema != null) {
        this._debug("_parse: using schema");
        if (utils.isString(input)) {
          if (this._custom_schema) {
            this._debug("_parse: this is a custom schema, we need to update it");
            try {
              tmp = csvString.parse(input)[0];
              i = 0;
              for (_i = 0, _len = tmp.length; _i < _len; _i++) {
                item = tmp[_i];
                if (item.match(/^(?:\d+|\d+\.|\d+\.\d+|\.\d+)$/)) {
                  value = Number(item);
                  this._debug("_parse: " + value + " = (Number) " + item);
                  if ((value != null) && !isNaN(value) && isFinite(value)) {
                    this._schema[i][1] = 'Number';
                  }
                  i += 1;
                }
              }
              this._debug("_parse: updated schema: " + (pretty(this._schema)));
            } catch (_error) {
              exc = _error;
              this._debug("_parse: schema update failed: " + exc);
            }
          }
          try {
            output = utils.parse(this._schema, input);
          } catch (_error) {
            exc = _error;
            this._debug("_parse: couldn't parse input, trying to parse json from string");
            try {
              output = JSON.parse(input);
            } catch (_error) {
              exc = _error;
              this._debug("_parse: couldn't parse json input. I could use the object as is, but since you defined a schema I prefer to skip it");
              output = void 0;
            }
          }
        } else {
          this._debug("_parse: object is not a string, using schema to map named symbols..");
          for (k in input) {
            v = input[k];
            _ref = this._schema;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              col = _ref[_j];
              if (col[0] === k) {
                type = col[1];
                if (type != null) {
                  if (utils.isString(type)) {
                    switch (type) {
                      case 'Symbol':
                        output[k] = "" + v;
                        break;
                      case 'Number':
                        output[k] = Number(v);
                        break;
                      case 'Boolean':
                        output[k] = v ? true : false;
                        break;
                      case 'String':
                        output[k] = "" + v;
                        break;
                      default:
                        output[k] = "" + v;
                    }
                  } else {
                    tmp = type[v];
                    if (tmp != null) {
                      output[k] = tmp;
                    }
                  }
                }
              }
            }
          }
          output;
        }
      } else if (utils.isString(input)) {
        this._debug("_parse: no schema, trying to parse json from string");
        try {
          output = JSON.parse(input);
        } catch (_error) {
          exc = _error;
          this._debug(exc);
          this._debug("_parse: uh-oh, not a JSON. Trying CSV..");
          try {
            tmp = csvString.parse(input)[0];
            output = {};
            if (this._schema == null) {
              this._debug("_parse: no schema! trying to detect if the row is a header..");
              this._custom_schema = true;
              i = 0;
              this._schema = (function() {
                var _k, _len2, _results;
                _results = [];
                for (_k = 0, _len2 = tmp.length; _k < _len2; _k++) {
                  item = tmp[_k];
                  _results.push(["col" + (i++), 'String']);
                }
                return _results;
              })();
              inputIsProbablyHeader = (function(_this) {
                return function() {
                  var _k, _len2;
                  for (_k = 0, _len2 = tmp.length; _k < _len2; _k++) {
                    item = tmp[_k];
                    if (item.match(/^(?:\d+|\d+\.|\d+\.\d+|\.\d+)$/)) {
                      value = Number(item);
                      if ((value != null) && !isNaN(value) && isFinite(value)) {
                        _this._debug("_parse: definitely not a header");
                        return false;
                      }
                    }
                  }
                  _this._debug("_parse: maybe a header?");
                  return true;
                };
              })(this)();
              if (inputIsProbablyHeader) {
                this._debug("_parse: input looks like a header, writing schema and skipping");
              } else {
                this._debug("_parse: not a header, so creating dummy schema and re-parsing input");
                return this._parse(input);
              }
            }
          } catch (_error) {
            exc2 = _error;
            this._debug(exc2);
            this._debug("_parse: document is not a JSON object and not a CSV array: skipping it".yellow);
          }
        }
      } else {
        this._debug("_parse: object is not a string, so we won't parse it");
        output = input;
      }
      this._debug("_parse: " + (pretty(input)) + " =====> " + (pretty(output)));
      return output;
    };

    Fussy.prototype._extract = function(event, facts, prefix) {
      var key, value;
      if (facts == null) {
        facts = [];
      }
      if (prefix == null) {
        prefix = "";
      }
      this._debug("_extract(event)");

      /*
      This was supposed to be a built-in support for a "date" attribute
      TODO but it is a bit awkward: we should rather use the schema for that.
      let's disable it for now.
       */
      for (key in event) {
        value = event[key];
        key = prefix + key;
        if (utils.isString(value)) {
          this._debug("_extract: String");
          if (value !== "") {
            facts.push(['String', key, value]);
          }
        } else if (utils.isArray(value)) {
          this._debug("_extract: Array");
          facts.push(['Array', key, value]);
        } else if (utils.isNumber(value)) {
          this._debug("_extract: Number");
          facts.push(['Number', key, value]);
        } else if (utils.isBoolean(value)) {
          this._debug("_extract: Boolean");
          facts.push(['Boolean', key, value]);
        } else {
          this._extract(value, facts, key + ".");
        }
      }
      return facts;
    };

    Fussy.prototype.schema = function(schema) {
      if (schema == null) {
        throw "cannot set an undefined schema";
      }
      this._schema = utils.loadSchema(schema);
      return this;
    };

    Fussy.prototype.limit = function(limit) {
      if (limit == null) {
        return this._limit;
      }
      if (limit < 0) {
        throw "limit must be >= 0";
      }
      this._debug("limit(value) " + " // setting limit to ".grey + ("" + (pretty(limit))));
      this._limit = limit;
      return this;
    };

    Fussy.prototype.skip = function(skip) {
      if (skip == null) {
        return this._skip;
      }
      if (skip < 0) {
        throw "skip must be >= 0";
      }
      this._debug("skip(value) " + " // setting skip to ".grey + ("" + (pretty(skip))));
      this._skip = skip;
      return this;
    };


    /*
    Call a function on each item, synchronously
    (the function will only returns once all items have been read)
    This functions skips invalid items
     */

    Fussy.prototype.eachFeaturesSync = function(cb) {
      this._debug("eachFeaturesSync(cb)");
      return this._engine.eachSync((function(_this) {
        return function(item, eof) {
          var extracted, features, map, _i, _len, _ref;
          _this._debug("eachFeaturesSync: @_engine.eachSync (item=" + (pretty(item)) + ", eof=" + (pretty(eof)) + ")");
          if (eof) {
            cb(void 0, eof);
            return;
          }
          extracted = _this._parse(item);
          if (!extracted) {
            return;
          }
          _ref = _this._maps;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            map = _ref[_i];
            extracted = map(extracted);
            if (!extracted) {
              return;
            }
          }
          features = _this._extract(extracted);
          if (!features) {
            return;
          }
          return cb(features, eof);
        };
      })(this));
    };


    /*
    Call a function on each item, asynchronously
     */

    Fussy.prototype.eachFeaturesAsync = function(cb) {
      this._debug("eachFeaturesAsync(cb)");
      this._engine.eachAsync((function(_this) {
        return function(item, eof) {
          var extracted, features, map, _i, _len, _ref;
          _this._debug("eachFeaturesAsync: @_engine.eachAsync (item=" + (pretty(item)) + ", eof=" + (pretty(eof)) + ")");
          if (eof) {
            cb(void 0, eof);
            return;
          }
          extracted = _this._parse(item);
          if (!extracted) {
            return;
          }
          _ref = _this._maps;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            map = _ref[_i];
            extracted = map(extracted);
            if (!extracted) {
              return;
            }
          }
          features = _this._extract(extracted);
          if (!features) {
            return;
          }
          return cb(features, eof);
        };
      })(this));
    };

    Fussy.prototype.onComplete = function(onCompleteCb) {
      this._debug("_onCompleteCb:(onCompleteCb)");
      this._onCompleteCb = onCompleteCb;
      return this;
    };


    /*
    Create a new single query.
    Maybe you shouldn't use this directly?
     */

    Fussy.prototype.query = function(query) {
      if (query == null) {
        throw "Error: Fussy.query cannot be called without parameters".red;
      }
      return new Query(this, [query], true);
    };


    /*
    synchronously return an array
     */

    Fussy.prototype.toArray = function(cb) {
      var arr;
      if (cb != null) {
        this._debug("toArray: async");
        arr = [];
        this._engine.eachAsync((function(_this) {
          return function(item, eof) {
            var extracted, map, _i, _len, _ref;
            _this._debug("toArray: @_engine.eachSync (item=" + (pretty(item)) + ", eof=" + (pretty(eof)) + ")");
            if (eof) {
              cb(arr);
              return;
            }
            extracted = _this._parse(item);
            if (!extracted) {
              return;
            }
            _ref = _this._maps;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              map = _ref[_i];
              extracted = map(extracted);
              if (!extracted) {
                return;
              }
            }
            return arr.push(extracted);
          };
        })(this));
        return;
      }
      arr = [];
      this._debug("toArray: sync");
      this._engine.eachSync((function(_this) {
        return function(item, eof) {
          var extracted, map, _i, _len, _ref;
          _this._debug("toArray: @_engine.eachSync (item=" + (pretty(item)) + ", eof=" + (pretty(eof)) + ")");
          if (eof) {
            return;
          }
          extracted = _this._parse(item);
          if (!extracted) {
            return;
          }
          _ref = _this._maps;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            map = _ref[_i];
            extracted = map(extracted);
            if (!extracted) {
              return;
            }
          }
          return arr.push(extracted);
        };
      })(this));
      return arr;
    };


    /*
    Repair an object in-place
    Only fields that are undefined will be filled, others will be left untouched
     */

    Fussy.prototype.repair = function(objects, cb) {
      var batch, isSingle, key, obj, query, repair, select, where;
      if (objects == null) {
        throw "Error: Fussy.repair cannot be called without parameters".red;
      }
      if (objects.toArray != null) {
        objects = objects.toArray();
      }
      isSingle = !utils.isArray(objects);
      if (isSingle) {
        objects = [objects];
      }
      batch = (function() {
        var _i, _j, _len, _len1, _results;
        _results = [];
        for (_i = 0, _len = objects.length; _i < _len; _i++) {
          obj = objects[_i];
          repair = obj;
          select = Object.keys(obj);
          where = {};
          for (_j = 0, _len1 = select.length; _j < _len1; _j++) {
            key = select[_j];
            if (obj[key] != null) {
              where[key] = obj[key];
            }
          }
          _results.push({
            repair: repair,
            select: select,
            where: where
          });
        }
        return _results;
      })();
      query = new Query(this, batch, isSingle);
      return query.repair(cb);
    };


    /*
    Return the solution to an uncomplete json object
     */

    Fussy.prototype.solve = function(objects, cb) {
      var batch, isSingle, key, obj, query, select, where;
      if (objects == null) {
        throw "Error: Fussy.solve cannot be called without parameters".red;
      }
      if (objects.toArray != null) {
        objects = objects.toArray();
      }
      isSingle = !utils.isArray(objects);
      if (isSingle) {
        objects = [objects];
      }
      this._debug("solve: pre-processing objects");
      batch = (function() {
        var _i, _j, _len, _len1, _results;
        _results = [];
        for (_i = 0, _len = objects.length; _i < _len; _i++) {
          obj = objects[_i];
          select = Object.keys(obj);
          where = {};
          for (_j = 0, _len1 = select.length; _j < _len1; _j++) {
            key = select[_j];
            if (obj[key] != null) {
              where[key] = obj[key];
            }
          }
          _results.push({
            select: select,
            where: where
          });
        }
        return _results;
      })();
      query = new Query(this, batch, isSingle);
      return query.best(cb);
    };


    /*
    Return a new json object with random attribute value, depending on the
    probability of each
    there is an optional argument, 'n', to specify the number of desired instances
     */

    Fussy.prototype.pick = function(obj, n, cb) {
      var query, single;
      this._debug("pick(obj, n, cb)");
      n = utils.isNumber(n) ? n : 1;
      cb = utils.isFunction(n) ? n : cb;
      single = (function() {
        var key, select, where, _i, _len;
        if (obj == null) {
          obj = {};
        }
        select = Object.keys(obj);
        where = {};
        for (_i = 0, _len = select.length; _i < _len; _i++) {
          key = select[_i];
          if (obj[key] != null) {
            where[key] = obj[key];
          }
        }
        return {
          select: select,
          where: where
        };
      })();
      query = new Query(this, [single], true);
      return query.pick(n, cb);
    };


    /*
    generate() generates a generator function
     */

    Fussy.prototype.generate = function(obj, cb) {
      var query, single;
      this._debug("generate(obj, cb)");
      single = (function() {
        var key, select, where, _i, _len;
        if (obj == null) {
          obj = {};
        }
        select = Object.keys(obj);
        where = {};
        for (_i = 0, _len = select.length; _i < _len; _i++) {
          key = select[_i];
          if (obj[key] != null) {
            where[key] = obj[key];
          }
        }
        return {
          select: select,
          where: where
        };
      })();
      query = new Query(this, [single], true);
      return query.generate(cb);
    };


    /*
    test some data (this is a WIP, to repair the bench object)
     */

    Fussy.prototype.test = function(input, cb) {
      var testDataset;
      testDataset = module.exports.input(input);
      if (cb != null) {
        this._debug("test: async");
        return this.eachFeaturesAsync((function(_this) {
          return function(item, eof) {
            return 0;
          };
        })(this));
      } else {
        this._debug("test: sync");
        return this.eachFeaturesSync((function(_this) {
          return function(item, eof) {
            return 0;
          };
        })(this));
      }
    };


    /*
     */

    Fussy.prototype.similar = function(obj, n, cb) {
      n = utils.isNumber(n) ? n : 1;
      cb = utils.isFunction(n) ? n : cb;
      this._debug("similar(obj, " + (pretty(n)) + ", cb)");
      throw "Not Implemented";
    };

    return Fussy;

  })();

  module.exports = function(input) {
    return new Fussy(input, module.exports._debugEnabled);
  };

  module.exports.debug = function(enabled) {
    module.exports._debugEnabled = enabled;
    return module.exports;
  };

  module.exports.pretty = utils.pretty;

  module.exports.pperf = utils.pperf;

  module.exports.pstats = utils.pstats;

}).call(this);
