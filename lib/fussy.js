// Generated by CoffeeScript 1.7.1
(function() {
  var Database, File, Lazy, Mongo, Query, Url, colors, csv, debug, extract, mime, path, pretty, unzip, util, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  util = require('util');

  Url = require('url');

  Lazy = require('lazy.js');

  unzip = require('unzip');

  mime = require('mime');

  colors = require('colors');

  csv = require('ya-csv');

  utils = require('./utils');

  extract = require('./extract');

  pretty = utils.pretty;

  debug = function(x) {
    return console.log(x);
  };

  Query = (function() {
    function Query(db, q) {
      var select, tmp, _i, _len, _ref;
      this._error = void 0;
      if (q.select != null) {
        if (utils.isString(this.qlect)) {
          tmp = {};
          tmp[q.select] = [];
          q.select = tmp;
        } else if (utils.isArray(q.select)) {
          tmp = {};
          _ref = q.select;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            select = _ref[_i];
            tmp[select] = [];
          }
          q.select = tmp;
        }
      }
      if (!utils.isArray(q.where)) {
        q.where = [q.where];
      }
      this._db = db;
      this._query = q;
    }

    Query.prototype._reduceFn = function(reduction, features) {
      var complexity, delta, depth, factors, key, match, nb_feats, type, value, weight, where, whereValue, whereValues, _depth, _i, _j, _k, _l, _len, _len1, _len2, _len3, _nb_feats, _ref, _ref1, _ref2, _ref3;
      debug("Query::reduceFn(reduction, features)" + " // deep comparison".grey);
      weight = 0;
      factors = [];
      nb_feats = 0;
      _ref = query.where;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        where = _ref[_i];
        depth = 0;
        complexity = 0;
        for (_j = 0, _len1 = features.length; _j < _len1; _j++) {
          _ref1 = features[_j], type = _ref1[0], key = _ref1[1], value = _ref1[2];
          if (key in where) {
            whereValues = utils.isArray(where[key]) ? where[key] : [where[key]];
            match = false;
            for (_k = 0, _len2 = whereValues.length; _k < _len2; _k++) {
              whereValue = whereValues[_k];
              switch (type) {
                case 'String':
                  value = "" + value;
                  whereValue = "" + whereValue;
                  if (__indexOf.call(value, ' ') >= 0 || __indexOf.call(whereValue, ' ') >= 0) {
                    _ref2 = text.distance(value, whereValue), _depth = _ref2[0], _nb_feats = _ref2[1];
                    depth += _depth;
                    nb_feats += _nb_feats;
                    match = true;
                  } else {
                    if (value === whereValue) {
                      depth += 1;
                      match = true;
                    }
                  }
                  break;
                case 'Number':
                  whereValue = Number(whereValue);
                  if (!isNaN(whereValue) && isFinite(whereValue)) {
                    delta = Math.abs(value - whereValue);
                    depth += 1 / (1 + delta);
                    match = true;
                  }
                  break;
                case 'Boolean':
                  if ((Boolean(value)) === (Boolean(whereValue))) {
                    depth += 1;
                    match = true;
                  }
                  break;
                default:
                  debug("type " + type + " not supported");
              }
            }
            if (match) {
              nb_feats += 1;
            }
          }
        }
        depth *= Math.min(6, 300 / nb_feats);
        weight += Math.pow(10, Math.min(300, depth));
      }
      for (_l = 0, _len3 = features.length; _l < _len3; _l++) {
        _ref3 = features[_l], type = _ref3[0], key = _ref3[1], value = _ref3[2];
        if (query.select != null) {
          if (!(key in query.select)) {
            continue;
          }
        }
        if (!(key in reduction.types)) {
          reduction.types[key] = type;
        }
        if (!(key in reduction.result)) {
          reduction.result[key] = {};
        }
        if (!(value in reduction.result[key])) {
          reduction.result[key][value] = 0;
        }
        match = false;
        if (utils.isArray(query.select[key])) {
          if (query.select[key].length) {
            if (__indexOf.call(query.select[key], value) >= 0) {
              match = true;
            }
          } else {
            match = true;
          }
        } else {
          if (value === query.select[key]) {
            match = true;
          }
        }
        if (match) {
          reduction.result[key][value] += weight;
        }
      }
      debug("generated reduction result");
      return reduction;
    };

    Query.prototype._sortFn = function(input, cb) {
      var output;
      debug("Query::_sortFn(input, cb?)" + " // sort options by probability".grey);
      output = input.sort(function(a, b) {
        return b[2] - a[2];
      });
      if (cb != null) {
        cb(output);
        return void 0;
      } else {
        return output;
      }
    };

    Query.prototype._castFn = function(args, cb) {
      var __castFn;
      debug("Query::_castFn(args, cb?)" + "  // cast output map to typed array");
      __castFn = function(args) {
        var key, option, options, weight, _ref, _results, _results1, _results2;
        debug("Query::_castFn:__castFn(args)");
        _ref = args.result, key = _ref[0], options = _ref[1];
        if (args.types[key] === 'Number') {
          _results = [];
          for (option in options) {
            weight = options[option];
            _results.push([key, Number(option, weight)]);
          }
          return _results;
        } else if (args.types[key] === 'Boolean') {
          _results1 = [];
          for (option in options) {
            weight = options[option];
            _results1.push([key, Boolean(option, weight)]);
          }
          return _results1;
        } else {
          _results2 = [];
          for (option in options) {
            weight = options[option];
            _results2.push([key, option, weight]);
          }
          return _results2;
        }
      };
      if (cb != null) {
        cb(__castFn(args));
        return void 0;
      } else {
        return __castFn(args);
      }
    };

    Query.prototype.get = function(cb) {
      debug("Query::get(cb?)");
      if (cb != null) {
        return this.onComplete(cb);
      } else {
        return this.toArray();
      }
    };

    Query.prototype.toArray = function() {
      var casted, ctx, sorted;
      debug("Query::toArray()");
      ctx = {
        reduction: {
          result: {},
          types: {}
        }
      };
      debug("Query::toArray: @_db.eachFeatureSync:");
      this._db.eachFeaturesSync((function(_this) {
        return function(features, index, isLastItem) {
          debug("Query::toArray: @_db.eachFeatureSync(" + (prerry(features)) + "," + (pretty(index)) + "," + (pretty(isLastItem)) + ")");
          return ctx.reduction = _this._reduceFn(ctx.reduction, features);
        };
      })(this));
      debug("Query::toArray: @_castFn(sorted)");
      casted = this._castFn(ctx.reduction);
      debug("Query::toArray: @_sortFn(casted)");
      sorted = this._sortFn(casted);
      debug("Query::toArray: return");
      return sorted;
    };

    Query.prototype.onError = function(cb) {
      debug("Query::onError(cb)");
      return this._onError = cb;
    };

    Query.prototype.onComplete = function(cb) {
      var ctx;
      debug("Query::onComplete(cb)");
      ctx = {
        reduction: {
          result: {},
          types: {}
        }
      };
      debug("Query::onComplete: @_db.eachFeatureAsync:");
      this._db.eachFeaturesAsync((function(_this) {
        return function(features, index, isLastItem) {
          debug("Query::onComplete:   @_db.eachFeatureAsync(" + (pretty(features)) + "," + (pretty(index)) + "," + (pretty(isLastItem)) + ")");
          debug("Query::onComplete:     @_reduceFn(ctx.reduction, features)");
          ctx.reduction = _this._reduceFn(ctx.reduction, features);
          if (!isLastItem) {
            return;
          }
          debug("Query::onComplete:     isLastItem == true");
          debug("Query::onComplete:   @_castFn(ctx.reduction, cb)");
          return _this._castFn(ctx.reduction, function(casted) {
            debug("Query::onComplete:   @_sortFn(casted, cb)");
            return this._sortFn(casted, function(sorted) {
              debug("Query::onComplete: cb(sorted)");
              return cb(sorted);
            });
          });
        };
      })(this));
      return void 0;
    };

    return Query;

  })();

  File = (function() {
    function File(_fussy, _url) {
      var parsed;
      this._fussy = _fussy;
      this._url = _url;
      parsed = Url.parse(this._url);
      this._path = parsed.path;
      if (parsed.protocol == null) {
        this._path = this._url;
      }
    }

    File.prototype.eachSync = function(cb) {
      var fs, i, line, lines, str, _i, _len;
      debug("File::eachSync(cb)");
      fs = require('fs');
      str = fs.readFileSync(this._path, 'utf-8');
      lines = str.split('\n');
      i = 0;
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        cb(line, i, false);
        i += 1;
      }
      return cb(void 0, i, true);
    };

    File.prototype.eachAsync = function(cb) {
      var fs, i, instream, outstream, readline, rl, stream;
      debug("File::eachAsync(cb)");
      fs = require('fs');
      readline = require('readline');
      stream = require('stream');
      instream = fs.createReadStream(this._path);
      outstream = new stream;
      rl = readline.createInterface(instream, outstream);
      i = 0;
      rl.on('line', function(line) {
        cb(line, i, false);
        return i += 1;
      });
      rl.on('close', function() {
        return cb(void 0, i, true);
      });
      return void 0;
    };

    return File;

  })();

  Mongo = (function() {
    function Mongo(_fussy, _url) {
      var parsed, _ref, _ref1, _ref2;
      this._fussy = _fussy;
      this._url = _url;
      parsed = Url.parse(this._url);
      this._host = (_ref = parsed.hostname) != null ? _ref : '127.0.0.1';
      this._port = Number((_ref1 = parsed.port) != null ? _ref1 : '27017');
      path = (_ref2 = parsed.path) != null ? _ref2 : '/fussy/fussy';
      this._database = path[0];
      this._collection = path[1];
      this._batchSize = 1024;
    }

    Mongo.prototype.eachSync = function(cb) {
      var Server, cursor, db, i, item, limit, results, size, skip, _i, _len;
      debug('Mongo::eachSync');
      limit = this._fussy.limit();
      skip = this._fussy.skip();
      Server = require('mongo-sync').Server;
      db = new Server(this._host);
      debug("Mongo::eachSync: gettin cursor on database and collection");
      cursor = db.db(this._database).getCollection(this._collection).find();
      if (skip != null) {
        debug("Mongo::eachSync: skipping " + skip + " results of collection");
        cursor = cursor.skip(skip);
      }
      if (limit != null) {
        debug("Mongo::eachSync: limiting " + limit + " results of collection");
        cursor = cursor.limit(limit);
      }
      results = cursor.toArray();
      i = 0;
      size = results.length;
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        item = results[_i];
        cb(item, i, false);
      }
      cb(void 0, size, true);
      db.close();
      return void 0;
    };

    Mongo.prototype.eachAsync = function(cb) {
      var MongoClient, collection, delay, limit, skip;
      debug("Mongo::eachAsync(cb)");
      MongoClient = require('mongodb').MongoClient;
      collection = this._collection;
      limit = this._fussy.limit();
      skip = this._fussy.skip();
      delay = 0;
      debug("Mongo::eachAsync: connecting to mongo (" + this._host + ":" + this._port + ")");
      MongoClient.connect("mongodb://" + this._host + ":" + this._port + "/" + _database, function(err, db) {
        var cursor, _readCursor;
        if (err) {
          throw err;
        }
        debug("Mongo::eachAsync: gettin cursor on database and collection");
        cursor = db.collection(collection).find();
        if (skip != null) {
          debug("Mongo::eachSync: skipping " + skip + " results of collection");
          cursor = cursor.skip(skip);
        }
        if (limit != null) {
          debug("Mongo::eachSync: limiting " + limit + " results of collection");
          cursor = cursor.limit(limit);
        }
        cursor = cursor.batchSize(this._batchSize);
        _readCursor = function(cursor, i, delay, db, next) {
          return cursor.nextObject(function(err, item) {
            var fn;
            debug("Mongo::eachAsync:_readCursor: cursor.nextObject(function(err, item){})");
            if (err) {
              throw err;
            }
            if (item) {
              debug("                          - returned an item");
              cb(item, i, true);
              fn = function() {
                return next(cursor, i + 1, delay);
              };
              return setTimeout(fn, delay);
            } else {
              debug("                          - returned nothing: end reached");
              cb(void 0, i, true);
              return db.close();
            }
          });
        };
        debug("Mongo::eachAsync: calling _readCursor(cursor, 0, delay, db, next)");
        return _readCursor(cursor, 0, delay, db, _readCursor);
      });
      return void 0;
    };

    return Mongo;

  })();

  Database = (function() {
    function Database(input) {
      var parsed;
      this._skip = void 0;
      this._limit = void 0;
      parsed = Url.parse(input);
      switch (parsed.protocol) {
        case 'rest:':
        case 'http:':
        case 'http+rest:':
        case 'http+json':
        case 'https:':
        case 'https+rest:':
        case 'https+json':
          debug("Database::constructor: protocol is http rest");
          throw "http rest protocol is not supported yet";
          break;
        case 'file:':
        case 'file+csv:':
        case 'file+json:':
        case 'file+txt:':
          debug("Database::constructor: protocol is file");
          this._engine = new File(this, input);
          break;
        case 'mongo:':
        case 'mongodb:':
          debug("Database::constructor: protocol is MongoDB");
          this._engine = new Mongo(this, input);
          break;
        default:
          debug("Database::constructor: protocol is default (file)");
          this._engine = new File(this, input);
      }
    }

    Database.prototype._parse = function(input) {
      var exc, output;
      debug("Database::_parse(input) " + "  // convert raw chunk into full featured object".grey);
      output = void 0;
      if (this._schema != null) {
        if (utils.isString(input)) {
          debug("trying to parse csv line using schema");
          debug("line: " + input);
          try {
            output = utils.parse(this._schema, input);
          } catch (_error) {
            exc = _error;
            debug("Database::_parse: couldn't parse input, trying to parse json from string");
            try {
              output = JSON.parse(input);
            } catch (_error) {
              exc = _error;
              debug("Database::_parse: couldn't parse json input. I could use the object as is, but since you defined a schema I prefer to skip it");
              output = void 0;
            }
          }
        } else {
          output = input;
        }
      } else if (utils.isString(input)) {
        debug("Database::_parse: no schema, trying to parse json from string");
        output = JSON.parse(input);
      } else {
        debug("Database::_parse: no schema, using js object as-is");
        output = input;
      }
      debug("Database::_parse: " + (pretty(input)) + " =====> " + (pretty(output)));
      return output;
    };

    Database.prototype._extract = function(event, facts, prefix) {
      var exc, key, value;
      if (facts == null) {
        facts = [];
      }
      if (prefix == null) {
        prefix = "";
      }
      debug("Database::_extract(event)");

      /*
      This was supposed to be a built-in support for a "date" attribute
      TODO but it is a bit awkward: we should rather use the schema for that.
      let's disable it for now.
       */
      try {
        for (key in event) {
          value = event[key];
          key = prefix + key;
          if (utils.isString(value)) {
            facts.push(['String', key, value]);
          } else if (utils.isArray(value)) {
            facts.push(['Array', key, value]);
          } else if (utils.isNumber(value)) {
            facts.push(['Number', key, value]);
          } else if (utils.isBoolean(value)) {
            facts.push(['Boolean', key, value]);
          } else {
            this._extract(value, facts, key + ".");
          }
        }
      } catch (_error) {
        exc = _error;
        console.log("failed: " + exc);
        console.log(exc);
      }
      return facts;
    };

    Database.prototype.schema = function(schema) {
      if (schema == null) {
        throw "cannot set an undefined schema";
      }
      this._schema = schema;
      return this;
    };

    Database.prototype.limit = function(limit) {
      if (limit == null) {
        return this._limit;
      }
      if (limit < 0) {
        throw "limit must be >= 0";
      }
      debug("Database::limit(value) " + " // setting limit to ".grey + ("" + (pretty(limit))));
      this._limit = limit;
      return this;
    };

    Database.prototype.skip = function(skip) {
      if (skip == null) {
        return this._skip;
      }
      if (skip < 0) {
        throw "skip must be >= 0";
      }
      debug("Database::skip(value) " + " // setting skip to ".grey + ("" + (pretty(skip))));
      this._skip = skip;
      return this;
    };

    Database.prototype.eachFeaturesSync = function(cb) {
      debug("Database::eachFeaturesSync(cb)");
      return this._engine.eachSync((function(_this) {
        return function(item, index, eof) {
          var features;
          features = _this._extract(_this._parse(item));
          return cb(features, index, eof);
        };
      })(this));
    };

    Database.prototype.eachFeaturesAsync = function(cb) {
      debug("Database::eachFeaturesAsync(cb)");
      return this._engine.eachAsync((function(_this) {
        return function(item, index, eof) {
          var features;
          features = _this._extract(_this._parse(item));
          return cb(features, index, eof);
        };
      })(this));
    };

    Database.prototype.onComplete = function(onCompleteCb) {
      debug("Database::_onCompleteCb = onCompleteCb");
      this._onCompleteCb = onCompleteCb;
      return this;
    };

    Database.prototype.query = function(query) {
      return new Query(this, query);
    };

    return Database;

  })();

  module.exports = {
    pretty: utils.pretty,
    pperf: utils.pperf,
    pstats: utils.pstats,
    database: function(input) {
      return new Database(input);
    }
  };

}).call(this);
