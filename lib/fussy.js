// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var File, Fussy, Glob, Http, List, Mongo, Query, Url, colors, csvString, pretty, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Url = require('url');

  colors = require('colors');

  csvString = require('csv-string');

  utils = require('./utils');

  List = require('./protocols/list');

  File = require('./protocols/file');

  Glob = require('./protocols/glob');

  Http = require('./protocols/http');

  Mongo = require('./protocols/mongo');

  Query = require('./query');

  pretty = utils.pretty;

  Fussy = (function() {
    function Fussy(input, _debugEnabled) {
      var parsed;
      this._debugEnabled = _debugEnabled;
      this.eachFeaturesAsync = __bind(this.eachFeaturesAsync, this);
      this._skip = void 0;
      this._limit = void 0;
      this._firstLine = true;
      this._custom_schema = false;
      if (utils.isArray(input)) {
        this._engine = new List(this, input);
      } else if (utils.isString(input)) {
        parsed = Url.parse(input);
        switch (parsed.protocol) {
          case 'rest:':
          case 'http:':
          case 'http+rest:':
          case 'http+json':
          case 'https:':
          case 'https+rest:':
          case 'https+json':
            this._debug("constructor: protocol is http rest");
            this._engine(new Http(this, input));
            break;
          case 'file:':
          case 'file+csv:':
          case 'file+json:':
          case 'file+txt:':
            this._debug("constructor: protocol is file");
            if (parsed.path.slice(-1) === '/' || parsed.path.match(/\*/)) {
              this._engine = new Glob(this, input);
            } else {
              this._engine = new File(this, input);
            }
            break;
          case 'mongo:':
          case 'mongodb:':
            this._debug("constructor: protocol is MongoDB");
            this._engine = new Mongo(this, input);
            break;
          default:
            this._debug("constructor: protocol is default (file)");
            if (parsed.path.slice(-1) === '/' || parsed.path.match(/\*/)) {
              this._engine = new Glob(this, input);
            } else {
              this._engine = new File(this, input);
            }
        }
      } else {
        throw "unsupported input type";
      }
    }

    Fussy.prototype.debug = function(enabled) {
      this._debugEnabled = enabled;
      return this;
    };

    Fussy.prototype._debug = function(x) {
      if (!this._debugEnabled) {
        return;
      }
      return console.log("Fussy".yellow + "::".grey + x);
    };


    /*
     */

    Fussy.prototype._parse = function(input) {
      var exc, exc2, i, inputIsProbablyHeader, item, output, tmp, value, _i, _len;
      output = void 0;
      if (this._schema != null) {
        this._debug("_parse: using schema");
        if (utils.isString(input)) {
          if (this._custom_schema) {
            this._debug("_parse: this is a custom schema, we need to update it");
            try {
              tmp = csvString.parse(input)[0];
              i = 0;
              for (_i = 0, _len = tmp.length; _i < _len; _i++) {
                item = tmp[_i];
                value = Number(item);
                this._debug("_parse: " + value + " = (Number) " + item);
                if ((value != null) && !isNaN(value) && isFinite(value)) {
                  this._schema[i][1] = 'Number';
                }
                i += 1;
              }
              this._debug("_parse: updated schema: " + (pretty(this._schema)));
            } catch (_error) {
              exc = _error;
              this._debug("_parse: schema update failed: " + exc);
            }
          }
          try {
            output = utils.parse(this._schema, input);
          } catch (_error) {
            exc = _error;
            this._debug("_parse: couldn't parse input, trying to parse json from string");
            try {
              output = JSON.parse(input);
            } catch (_error) {
              exc = _error;
              this._debug("_parse: couldn't parse json input. I could use the object as is, but since you defined a schema I prefer to skip it");
              output = void 0;
            }
          }
        } else {
          this._debug("_parse: object is not a string, so we won't parse it");
          output = input;
        }
      } else if (utils.isString(input)) {
        this._debug("_parse: no schema, trying to parse json from string");
        try {
          output = JSON.parse(input);
        } catch (_error) {
          exc = _error;
          this._debug(exc);
          this._debug("_parse: uh-oh, not a JSON. Trying CSV..");
          try {
            tmp = csvString.parse(input)[0];
            output = {};
            if (this._schema == null) {
              this._debug("_parse: no schema! trying to detect if the row is a header..");
              this._custom_schema = true;
              this._schema = (function() {
                var _j, _len1, _results;
                _results = [];
                for (_j = 0, _len1 = tmp.length; _j < _len1; _j++) {
                  item = tmp[_j];
                  _results.push([item, 'String']);
                }
                return _results;
              })();
              inputIsProbablyHeader = (function() {
                var _j, _len1;
                for (_j = 0, _len1 = tmp.length; _j < _len1; _j++) {
                  item = tmp[_j];
                  value = Number(item);
                  if ((value != null) && !isNaN(value) && isFinite(value)) {
                    this._debug("_parse: definitely not a header");
                    return false;
                  }
                }
                this._debug("_parse: maybe a header?");
                return true;
              })();
              if (inputIsProbablyHeader) {
                this._debug("_parse: input looks like a header, writing schema and skipping");
              } else {
                this._debug("_parse: not a header, so creating dummy schema and re-parsing input");
                return this._parse(input);
              }
            }
          } catch (_error) {
            exc2 = _error;
            this._debug(exc2);
            this._debug("_parse: document is not a JSON object and not a CSV array: skipping it".yellow);
          }
        }
      } else {
        this._debug("_parse: object is not a string, so we won't parse it");
        output = input;
      }
      this._debug("_parse: " + (pretty(input)) + " =====> " + (pretty(output)));
      return output;
    };

    Fussy.prototype._extract = function(event, facts, prefix) {
      var key, value;
      if (facts == null) {
        facts = [];
      }
      if (prefix == null) {
        prefix = "";
      }
      this._debug("_extract(event)");

      /*
      This was supposed to be a built-in support for a "date" attribute
      TODO but it is a bit awkward: we should rather use the schema for that.
      let's disable it for now.
       */
      for (key in event) {
        value = event[key];
        key = prefix + key;
        if (utils.isString(value)) {
          this._debug("_extract: String");
          if (value !== "") {
            facts.push(['String', key, value]);
          }
        } else if (utils.isArray(value)) {
          this._debug("_extract: Array");
          facts.push(['Array', key, value]);
        } else if (utils.isNumber(value)) {
          this._debug("_extract: Number");
          facts.push(['Number', key, value]);
        } else if (utils.isBoolean(value)) {
          this._debug("_extract: Boolean");
          facts.push(['Boolean', key, value]);
        } else {
          this._extract(value, facts, key + ".");
        }
      }
      return facts;
    };

    Fussy.prototype.schema = function(schema) {
      if (schema == null) {
        throw "cannot set an undefined schema";
      }
      this._schema = utils.loadSchema(schema);
      return this;
    };

    Fussy.prototype.limit = function(limit) {
      if (limit == null) {
        return this._limit;
      }
      if (limit < 0) {
        throw "limit must be >= 0";
      }
      this._debug("limit(value) " + " // setting limit to ".grey + ("" + (pretty(limit))));
      this._limit = limit;
      return this;
    };

    Fussy.prototype.skip = function(skip) {
      if (skip == null) {
        return this._skip;
      }
      if (skip < 0) {
        throw "skip must be >= 0";
      }
      this._debug("skip(value) " + " // setting skip to ".grey + ("" + (pretty(skip))));
      this._skip = skip;
      return this;
    };


    /*
    Call a function on each item, synchronously
    (the function will only returns once all items have been read)
    This functions skips invalid items
     */

    Fussy.prototype.eachFeaturesSync = function(cb) {
      this._debug("eachFeaturesSync(cb)");
      return this._engine.eachSync((function(_this) {
        return function(item, eof) {
          var extracted, features;
          _this._debug("eachFeaturesSync: @_engine.eachSync (item=" + (pretty(item)) + ", eof=" + (pretty(eof)) + ")");
          if (eof) {
            cb(void 0, eof);
            return;
          }
          extracted = _this._parse(item);
          if (!extracted) {
            return;
          }
          features = _this._extract(extracted);
          if (!features) {
            return;
          }
          return cb(features, eof);
        };
      })(this));
    };


    /*
    Call a function on each item, asynchronously
     */

    Fussy.prototype.eachFeaturesAsync = function(cb) {
      this._debug("eachFeaturesAsync(cb)");
      this._engine.eachAsync((function(_this) {
        return function(item, eof) {
          var extracted, features;
          _this._debug("eachFeaturesAsync: @_engine.eachAsync (item=" + (pretty(item)) + ", eof=" + (pretty(eof)) + ")");
          if (eof) {
            cb(void 0, eof);
            return;
          }
          extracted = _this._parse(item);
          if (!extracted) {
            return;
          }
          features = _this._extract(extracted);
          if (!features) {
            return;
          }
          return cb(features, eof);
        };
      })(this));
    };

    Fussy.prototype.onComplete = function(onCompleteCb) {
      this._debug("_onCompleteCb:(onCompleteCb)");
      this._onCompleteCb = onCompleteCb;
      return this;
    };

    Fussy.prototype.query = function(query) {
      if (query == null) {
        throw "Error: Fussy.query cannot be called without parameters".red;
      }
      return new Query(this, query);
    };


    /*
    Repair an object in-place
    Only fields that are undefined will be filled, others will be left untouched
     */

    Fussy.prototype.repair = function(obj, cb) {
      var query;
      if (obj == null) {
        throw "Error: Fussy.repair cannot be called without parameters".red;
      }
      query = new Query(this, {
        replace: obj,
        select: Object.keys(obj),
        where: (function() {
          var key, newObj, _i, _len, _ref;
          newObj = {};
          _ref = Object.keys(obj);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            if (obj[key] != null) {
              newObj[key] = obj[key];
            }
          }
          return newObj;
        })()
      });
      return query.replace(cb);
    };


    /*
    Return the solution to an uncomplete json object
     */

    Fussy.prototype.solve = function(obj, cb) {
      var query;
      if (obj == null) {
        throw "Error: Fussy.solve cannot be called without parameters".red;
      }
      this._debug("solve(obj, cb)");
      query = new Query(this, {
        select: Object.keys(obj),
        where: (function() {
          var key, newObj, _i, _len, _ref;
          newObj = {};
          _ref = Object.keys(obj);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            if (obj[key] != null) {
              newObj[key] = obj[key];
            }
          }
          return newObj;
        })()
      });
      return query.best(cb);
    };


    /*
    Return a new json object with random attribute value, depending on the
    probability of each
    there is an optional argument, 'n', to specify the number of desired instances
     */

    Fussy.prototype.pick = function(obj, n, cb) {
      var query;
      this._debug("pick(obj, n, cb)");
      n = utils.isNumber(n) ? n : 1;
      cb = utils.isFunction(n) ? n : cb;
      if (obj == null) {
        obj = {};
      }
      query = new Query(this, {
        select: Object.keys(obj),
        where: (function() {
          var key, newObj, _i, _len, _ref;
          newObj = {};
          _ref = Object.keys(obj);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            if (obj[key] != null) {
              newObj[key] = obj[key];
            }
          }
          return newObj;
        })()
      });
      return query.pick(n, cb);
    };


    /*
    generate() generates a generator function
     */

    Fussy.prototype.generate = function(obj, cb) {
      var query;
      this._debug("generate(obj, cb)");
      if (obj == null) {
        obj = {};
      }
      query = new Query(this, {
        select: Object.keys(obj),
        where: (function() {
          var key, newObj, _i, _len, _ref;
          newObj = {};
          _ref = Object.keys(obj);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            if (obj[key] != null) {
              newObj[key] = obj[key];
            }
          }
          return newObj;
        })()
      });
      return query.generate(cb);
    };


    /*
    test some data (this is a WIP, to replace the bench object)
     */

    Fussy.prototype.test = function(input, cb) {
      var testDataset;
      testDataset = module.exports.input(input);
      if (cb != null) {
        this._debug("test: async");
        return this.eachFeaturesAsync((function(_this) {
          return function(item, eof) {
            return 0;
          };
        })(this));
      } else {
        this._debug("test: sync");
        return this.eachFeaturesSync((function(_this) {
          return function(item, eof) {
            return 0;
          };
        })(this));
      }
    };

    return Fussy;

  })();

  module.exports = function(input) {
    return new Fussy(input, module.exports._debugEnabled);
  };

  module.exports.debug = function(enabled) {
    module.exports._debugEnabled = enabled;
    return module.exports;
  };

  module.exports.pretty = utils.pretty;

  module.exports.pperf = utils.pperf;

  module.exports.pstats = utils.pstats;

}).call(this);
